# 汇编与二进制漏洞 第2讲 cpu结构介绍

## 进制

逆向分析常用的进制有：
- 二进制
- 八进制
- 十进制
- 十六禁止

## CPU架构

- 寄存器组
- 高频时钟
- 控制单元
- 数据逻辑单元

## 指令周期

1. CPU从指令队列（内存）取出第一条指令；
2. CPU对指令的二进制位模式进行译码。
3. 若有操作数，则从内存中取出操作数
4. 执行指令，更新寄存器；
5. 将结果存放到内存中。

简单说：取值-译码-执行。

## 加载执行过程

在程序执行之前，需要用一种工具程序将其加载到内存，这种工具程序成为程序加载器。加载后，操作系统必须将CPU指向程序的入口，即程序开始执行的地址。具体步骤为：

1. 操作系统在当前磁盘目录下搜索程序的文件名。如果找不到，则在预定目录列表下搜索文件名；当OS无法检索到文件名时，它会发出一个报错信息。
2. 如果程序文件被找到，OS就访问磁盘目录中的程序文件基本信息，包括文件大小，及其在磁盘驱动器上的物理位置。
3. OS确定内存中下一个可使用的位置，将程序文件加载到内存。为该程序分配内存块，并将程序大小和位置信息加入表中（有时候成为描述符表descriptor table）。另外，OS可能调整程序内指针的值，使得他们包括程序数据地址。
4. OS 开始执行程序的第一条机器指令（入口）。当程序开始执行后，就成为了一个进程。OS为这个进程分配一个标识号，用于执行期间对其进行追踪。
5. 进程自动运行。OS的工作就是追踪进程的执行，并相应系统资源的请求。这些资源包括内存、磁盘文件和输入输出设备等。
6. 进程结束，就会从内存中移除。

## x86处理器

### 3种模式

#### 保护模式（Protected Mode）。

这是最常见的模式，这是一个受保护的并且支持多任务的环境。之所以受保护是因为在这个模式下，能够对内存及一些外围设备提供硬件级别的保护设置，如分段机制，分页机制。大部分OS都运行在这个模式下。

32位保护模式下，一个程序或任务最大可寻址空间为$2^32 = 4GB$线性地址空间。

从Intel P6 cpu开始，一种被称作扩展物理寻址的技术，使得可以被寻址的物理内存空间增加到64GB。

如果cpu在保护模式下运行多个虚拟8086程序（工作于实地址模式），则每个程序只能拥有自己的1MB空间。

#### 实地址模式（Read-address mode）。

这个运行模式是为了兼容8086处理器，通常处理器上电后会处于这个模式，在实地址模式中，寻址空间只有1MB，CS、DS等称作Segment register，即段的基地址直接是Segment register的值向左移4位。在保护模式下，CS、DS等称作Segment selector，用于从GDT（Global Descriptor Table）或LDT（Local Descriptor Table）表中选择一个段描述符，基地址在段描述符内，两种情况下用法不一样，所以两者的寻址空间也差别很大。

32位的cpu的实地址模式只能寻址1MB空间。

#### 系统管理模式（System management mode ，SMM）。

这个模式提供一个跟平台相关的管理环境，比如电源管理，RAS（Reliability, Avaliability and Serviceability）功能配置或者系统安全等相关问题。这个模式下的code通常是由UEFI/BIOS提供的，对OS来说是透明的。SMM有自己独立的地址空间，OS是看不到的。处理器接收到SMI pin上的中断信号或者APIC接收到SMI中断信号的时候才会进入到SMM模式。

### Intel 64结构新模式

这个架构添加了IA-32e模式，并且IA-32e模式中又有两种子模式：

#### 兼容模式（Compatibility mode）。

兼容模式顾名思义，就是向前兼容IA-32的模式，该模式允许传统的16-bit和32-bit的程序不需要重新编译就可以跑在64-bit的 OS下。

#### 64位模式（64-bit mode）。

这个模式让应用程序能够访问64位的地址，并且该模式扩展了通用寄存器的宽度和数量。

为了简单起见，Intel 64的兼容模式和64位模式也可以叫做IA-32的兼容模式和64位模式。


## x86寄存器组

### 通用数据寄存器（可进行8、16、32位操作）
- EAX
"累加器"(accumulator), 它是很多加法乘法指令的缺省寄存器 ；存放函数返回值。
- ECX:
是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器.
- EDX
总是被用来放整数除法产生的余数

### 通用寻址寄存器（能进行16、32位操作）
- EBX
基地址寄存器
- EBP
"基址指针"(BASE POINTER), 它最经常被用作高级语言函数调用的"框架指针",EBP 构成了函数的一个框架，在C++反汇编中 ebp-通常是局部变量、传进来的参数
- ESP
堆栈指针，指向当前的栈顶
- ESI/EDI
分别叫做"源/目标变址寄存器"(source/destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.

### 标志寄存器(EFLAGS)
包含可独立读取的多个标志位。
#### 运算结果标志位

- 进位标志CF(Carry Flag)

进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。

- 奇偶标志PF(Parity Flag)

奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。
- 辅助进位标志AF(Auxiliary Carry Flag)

在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：(1)、在字操作时，发生低字节向高字节进位或借位时(2)、在字节操作时，发生低4位向高4位进位或借位时。

对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。

- 零标志ZF(Zero Flag)

零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。

- 符号标志SF(Sign Flag)

符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。

- 溢出标志OF(Overflow Flag)

溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。

“溢出”和“进位”是两个不同含义的概念，不要混淆。如果不太清楚的话，请查阅《计算机组成原理》课程中的有关章节。

#### 状态控制标志位

状态控制标志位是用来控制CPU操作的，它们要通过专门的指令才能使之发生改变。

- 追踪标志TF(Trap Flag)

当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。

指令系统中没有专门的指令来改变标志位TF的值，但程序员可用其它办法来改变其值。

- 中断允许标志IF(Interrupt-enable Flag)

中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：(1)、当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；(2)、当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。

CPU的指令系统中也有专门的指令来改变标志位IF的值。

- 方向标志DF(Direction Flag)

方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。在微机的指令系统中，还提供了专门的指令来改变标志位DF的值。

#### 32位标志寄存器增加的标志位

- I/O特权标志IOPL(I/O Privilege Level)

I/O特权标志用两位二进制位来表示，也称为I/O特权级字段。该字段指定了要求执行I/O指令的特权级。如果当前的特权级别在数值上小于等于IOPL的值，那么，该I/O指令可执行，否则将发生一个保护异常。

- 嵌套任务标志NT(Nested Task)

嵌套任务标志NT用来控制中断返回指令IRET的执行。具体规定如下：(1)、当NT=0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的中断返回操作；(2)、当NT=1，通过任务转换实现中断返回。

- 重启动标志RF(Restart Flag)

重启动标志RF用来控制是否接受调试故障。规定：RF=0时，表示“接受”调试故障，否则拒绝之。在成功执行完一条指令后，处理机把RF置为0，当接受到一个非调试故障时，处理机就把它置为1。

- 虚拟8086方式标志VM(Virtual 8086 Mode)

如果该标志的值为1，则表示处理机处于虚拟的8086方式下的工作状态，否则，处理机处于一般保护方式下的工作状态。

### 段寄存器（存放段基址）

以下位16位的段寄存器：
- CS
- SS
- DS
- ES
- FS
- GS

### 指令指针寄存器

EIP

## XMM寄存器

x86结构cpu还包含8个128位XMM寄存器，用于SIMD流扩展指令集。

> SSE(Streaming SIMD Extensions) 是指令集的简称，它包括70条指令，其中包含单指令多数据浮点计算、以及额外的SIMD整数和高速缓存控制指令。其优势包括：更高分辨率的图像浏览和处理、高质量音频、MPEG2视频、同时MPEG2加解密；语音识别占用更少CPU资源；更高精度和更快响应速度。

### 80位数据寄存器

- ST（0）
- ST（1）
- ST（2）
- ST（3）
- ST（4）
- ST（5）
- ST（6）
- ST（7）

### 48位指针寄存器

- FPU指令指针
- FPU数据指针

### 16位控制寄存器

- 标志寄存器
- 控制寄存器
- 状态寄存器

### 操作吗寄存器