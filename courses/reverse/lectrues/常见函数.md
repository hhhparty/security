# 常见函数的汇编表示
## F
### fopen

FILE *fopen(const char *filename, const char *mode) 使用给定的模式 mode 打开 filename 所指向的文件。

参数
filename -- 这是 C 字符串，包含了要打开的文件名称。
mode -- 这是 C 字符串，包含了文件访问模式，模式如下：
模式	描述
"r"	打开一个用于读取的文件。该文件必须存在。
"w"	创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。
"a"	追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。
"r+"	打开一个用于更新的文件，可读取也可写入。该文件必须存在。
"w+"	创建一个用于读写的空文件。
"a+"	打开一个用于读取和追加的文件。
返回值
该函数返回一个 FILE 指针。否则返回 NULL，且设置全局变量 errno 来标识错误。

实例
下面的实例演示了 fopen() 函数的用法。
```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
   FILE * fp;

   fp = fopen ("file.txt", "w+");
   fprintf(fp, "%s %s %s %d", "We", "are", "in", 2014);
   
   fclose(fp);
   
   return(0);
}
```

```s
lea rsi, modes; 'r' or 'w' or 'a'
lea rdi, filename; '../somefile'

call fopen

```

## P

### puts

```masm
0x08049373      8d831ee0ffff   lea eax, [ebx - 0x1fe2]
0x08049379      50             push eax
0x0804937a      e8d1fcffff     call sym.imp.puts           ; int puts(const char *s)                                            
```
步骤：
- 将要输出的字符串地址放入eax
- 将eax 押入堆栈
- 调用puts函数。
#### x86.get_pc_thunk.bx


事实上常见的形式是：

```masm
0x0804934e      53             push ebx
0x0804934f      51             push ecx
0x08049350      83ec10         sub esp, 0x10
0x08049353      e878fdffff     call sym.__x86.get_pc_thunk.bx
0x08049358      81c3a82c0000   add ebx, 0x2ca8

```
这是将GOT（global offset table）的地址保存到ebx寄存器中。如果使用`-m32` 编译，那么程序使用32位机器码，而不支持64位机器相对的 rip寻址，所以要借助__x86.get_pc_thunk.bx实现寻址。

具体地可进入该调用，看到：
```ASM
sym.__x86.get_pc_thunk.bx ();
0x080490d0      8b1c24         mov ebx, dword [esp]
0x080490d3      c3             ret
```
从指令上看，是将 `[esp]`指针指向内容放入ebx，然后返回。非常简单，就两行汇编代码。首先取出%esp寄存器中的值，将其存放到%ebx寄存器中。%esp寄存器中的值是什么呢？其实就是__x86.get_pc_thunk.bx的调用者的下一条指令在内存中的地址，也就是main函数中 0x08049358 处`add ebx, 0x2ca8` 这条指令的地址。为什么呢？因为call指令会首先把返回地址（也就是上述指令的地址）压入栈中，然后再跳转到目标函数（__x86.get_pc_thunk.bx）处。在__x86.get_pc_thunk.bx中，%esp寄存器中的值就是 `add ebx, 0x2ca8`  这条指令的地址！__x86.get_pc_thunk.bx返回后，再执行 `add ebx, 0x2ca8`  ，其中$0x2ca8是该指令与GOT之间的偏移值，可以在编译期确定。0x08049358+0x2ca8=0x0804c000。果然，0x0804c000处的内容正是GOT！这样，%ebx寄存器中的值就是GOT的地址了。

```S
[0x0804c000]> pdf
            ;-- section..got.plt:
┌ 38: obj._GLOBAL_OFFSET_TABLE_ ();
│           0x0804c000      14bf           adc al, 0xbf                ; [22] -rw- section size 32 named .got.plt
│           0x0804c002      0408           add al, 8
│           0x0804c004      d0f9           sar cl, 1
│           0x0804c006      f4             hlt
..
│           0x0804c008      d03cf3         sar byte [ebx + esi*8], 1
..
│           ; DATA XREF from sym.imp.strcmp @ 0x8049030
│           ;-- reloc.strcmp:
│           0x0804c00c      3690           nop                         ; RELOC 32 strcmp
│           0x0804c00e      0408           add al, 8
│           ; DATA XREF from sym.imp.strcpy @ 0x8049040
│           ;-- reloc.strcpy:
│           0x0804c010      46             inc esi                     ; RELOC 32 strcpy
│           0x0804c011      90             nop
│           0x0804c012      0408           add al, 8
│           ; DATA XREF from sym.imp.puts @ 0x8049050
│           ;-- reloc.puts:
│           0x0804c014      56             push esi                    ; RELOC 32 puts
│           0x0804c015      90             nop
│           0x0804c016      0408           add al, 8
│           ; DATA XREF from sym.imp.__libc_start_main @ 0x8049060
│           ;-- reloc.__libc_start_main:
│           0x0804c018      20b8d2f77690   and byte [eax - 0x6f89082e], bh; RELOC 32 __libc_start_main
│           0x0804c01e      0408           add al, 8
            ;-- section..data:
            ;-- __data_start:
..
            ; XREFS: DATA 0x080490e0  DATA 0x080490e5  DATA 0x080490fb  DATA 0x08049120                                                                                     
            ; XREFS: DATA 0x08049125  DATA 0x08049148  DATA 0x08049164  DATA 0x08049178                                                                                     
            ;-- section..bss:
            ;-- _edata:
            ;-- __bss_start:
            ;-- __TMC_END__:

```


类似的函数还有：__x86.get_pc_thunk.ax，__x86.get_pc_thunk.cx， __x86.get_pc_thunk.dx。
功能是类似的，只不过传入的寄存器分别为%ebx， %ecx， %edx。早期版本的编译器中，这个函数叫__i686.get_pc_thunk.ax。

##### 另一种情况
还有的地方有下列指令

```
00000559 <__x86.get_pc_thunk.ax>:
 559:  8b 04 24               mov    (%esp),%eax
 55c:  c3                     ret    
 55d:  66 90                  xchg   %ax,%ax
 55f:  90                     nop
```

简单来说，该函数的功能是将%eip寄存器内容传入%eax寄存器。相当于mov %eip,%eax。
这个函数在x86上的PIC(position independent code，即位置无关代码)中使用。它将%eip的位置加载到%eax寄存器中，从而实现对模块内部数据（例如全局变量）的访问。
原因是x86的指令集中没有直接读取%eip的指令。

## S
### scanf


常见情况
```S
...
0x08049385      8d45f4         lea eax, [var_ch]
0x08049388      50             push eax
0x08049389      8d8334e0ffff   lea eax, [ebx - 0x1fcc]
0x0804938f      50             push eax
0x08049390      e8dbfcffff     call sym.imp.__isoc99_scanf ; int scanf(const char *format)  

# 另一种情况

0x08048577      8d4588         lea eax, [var_78h]        
0x0804857a      89442404       mov dword [var_4h], eax    
0x0804857e      c70424b28604.  mov dword [esp], 0x80486b2  ;
0x08048585      e8eafdffff     call sym.imp.scanf         
```

步骤：
- 将参数2（即存放数据的地址） 压入堆栈（或使用mov 指令放入【esp+4】）
- 将参数1（即format字符）压入堆栈（放入【esp】）
- 调用scanf函数

### strncmp()
`int strncmp ( const char * str1, const char * str2, size_t num );`

Compare characters of two strings

Compares up to num characters of the C string str1 to those of the C string str2.

该函数，按字符顺序结对比较，即str1的第一个字符与str2的第一个字符比较（做ascii码减法），若相同，则比较第二个字符对（仍作ASCII码减法），直到所有字符比较完或者比较次数大于num才结束。

返回结果为0时，为相等。

This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ, until a terminating null-character is reached, or until num characters match in both strings, whichever happens first.

Returns an integral value indicating the relationship between the strings:
|return value	|indicates|
|-|-|
|<0	|the first character that does not match has a lower value in str1 than in str2|
|0|	the contents of both strings are equal|
|>0|	the first character that does not match has a greater value in str1 than in str2|

```S
0x080484e6      c74424080300.  mov dword [n], 3            ; size_t n
0x080484ee      c74424043887.  mov dword [s2], str.LOLO    ; 
0x080484f6      8b0411         mov eax, dword [ecx + edx]
0x080484f9      890424         mov dword [esp], eax        ;  0x080484fc      e8d7feffff     call sym.imp.strncmp       
```


## M
### main 环境变量的位置

main 函数的参数 arg_10 = ebp + 0x10，main 函数栈帧的 ebp+0x10 位置存放了指向环境变量的指针，即 ebp = 0xff9260c8;【ebp+0x10】= 0xff9266ca; 【0xff9266ca】=“环境变量字符串”。

假设： 
```S
ebp = 0xff96c768
ebp + 0x10 = 0xff96c778

[ebp+0x10] = 0xff96c81c 

# 0xff96c814 - 0xff96c768 = 172 = 0xac
[0xff96c814] = 0xff96e626
# 0xff96c81c - 0xff96c768 = 180 = 0xb4
[0xff96c81c] = 0xff96e66b


# 0xff96e626- ebp = 7870 = 0x1ebe
[0xff96e626] = "/home/leo/workspace/r2test/ifding/t3/IOLI-crackme/bin-linux/LOLOLOLO.LANG=zh_CN.UTF-8.USER=leo.LOGNAME=leo.HOME=/home/leo.PATH=/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/home/leo/.dotnet/t...."

# 0xff96c81c - 0xff96c768 = 180 = 0xb4
[0xff96c81c] = 0xff96e66b


[0xff96e66b] = "LANG=zh_CN.UTF-8.USER=leo.LOGNAME=leo.HOME=/home/leo.PATH=/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/home/leo/.dotnet/t...."
#0xff96e66b - ebp = 7939
```
## References

- c++ references

http://www.cplusplus.com/reference/cstring/strncmp/