# 逆向分析 01

逆向分析在这里指的是对源文件进行编译链接后的结果——可执行文件进行分析。

例如有以下源文件 hello.c

```c
$ cat hello.c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    printf("Hello, world!\n");
    exit(0);
}
```
通过 gcc 进行编译：`gcc hello.c -o hello`，得到 hello 这个可以执行文件。

```sh
$ gcc -o hello hello.c
$ ./hello
Hello, world!
```

逆向一个 binary 文件，首先要知道这个文件是什么结构的？例如：
- elf file for linux
- pe file for windows

在linux下，常用的文件信息分析工具有不少，例如：
- file
- strings
- xxd
- objdump
- readelf

在windows 下，也有一些分析工具：
- PE explorer
- dependecy walker
- fileinfo
## 指令集

对于嵌入式系统、PMDs等，通常使用精简指令集（ Reduced Instruction Set Computing，RISC），而x86集群、桌面系统等通常使用复杂指令集（ Complex Instruction Set Computing ，CISC）

## 内存和寄存器

### 内存
内存是存储程序运行时代码和数据的载体，没有内存，CPU无法独立工作。

内存存储数据或指令以字节为单位，而在大内存中寻找这些指令或数据需要某种依据，这个依据就是内存地址（address）。每个内粗字节都有一个地址。
- 对于 32 位系统，系统寻址空间为 $2^{32}$ 
  - 即 4,294,967,296 Bytes (4 Gibibytes) (approx. 4 Gigabytes)
  - 地址范围：0x00000000 - 0xffffffff
- 对于 64 位系统，系统寻址空间为 $2^{64}$ 
  - 即 18,446,744,073,709,551,616 Bytes (16 Exbibytes) (approx. 16 Exabytes)
  - 地址范围：0x0000000000000000 -0xffffffffffffffff

系统会为每个进程授予全地址空间（$2^{32}$ 或 $2^{64}$ 的虚拟地址空间），但实际上进程很少能用这么大的空间。

<img src="images/reversing/内存结构示意图.png">

上图显示的是一个64位系统中可寻址内存的大致情况。

说明：
- .text 表示存放可执行代码的section/节
- .rodata/.data 表示存放初始化变量的section
- 所有的代码（.text）和数据都在 0x0 和 0xd80000 之间，大约14MB
- heap 表示 malloc（动态分配）的缓存内存区
- shared libraries 表示 C 的标准库所在的位置
- stack 表示本地/局部函数缓冲区。堆栈起食欲 0x7ffffffff，大约有2GB的空间用于 heap 和 stack 的增长。



### 寄存器

寄存器是CPU内部的高速存储单元，常见的寄存器有：
- rip 指令指针
- 通用寄存器
  - rax 累加寄存器
  - rbx 基数寄存器
  - rcx 计数寄存器
  - rdx 扩展寄存器
- 堆栈寄存器
  - rsp 堆栈指针
  - rbp 基址寄存器
- 数据/变址寄存器
  - rsi 原变址
  - rdi 目的变址
- 其他
  - r8～r15
- flags（标志寄存器）


寄存器的位数：
- rax 64bits
- eax 32b
- ax 16b
- ah 高8b
- al 低8b

系统调用（常见情况）：
- rax 系统调用数
- rdi arg0
- rsi arg1
- rdx arg2
- r10-r8-r9 ：arg3～arg5

## 汇编
### 指令

有两种指令格式类型：Intel 和 AT&T
- Intel指令格式：`opcode dst, src`
- AT&T指令格式：`opcode src, dst`

例如：`objdump -Mintel -D ./hello |grep "main>:" -A 8`

每条指令执行后，会影响的内容（side effects）：
- CPU flags，例如 cmp、test、jump指令都会影响标准寄存器
- 内村 stack，例如 push、pop、call、leave、ret

指令执行顺序控制：
- call
- jump

### 函数的 prologue （前沿）和 epilogue（后记）


#### Syscalls（系统调用）：
- rax ：常用于存放系统调用数
- rdi ：常用于存放arg0
- rsi ：常用于存放arg1
- rdx ：常用于存放arg2
- r10-r9-r8 常用于存放 arg3，arg4，arg5 

#### 函数调用

- rax： 用于存放返回结果（ret value）
- rdi：用于存放arg0
- rsi：用于存放arg1
- rdx ：常用于存放arg2
- rcx-r9-r8 常用于存放 arg3，arg4，arg5 

#### call指令

`call <address>` 等同于依次执行下列两条指令:
-  `push rip+len(instruc)`
-  `jmp <address>`

#### 函数 prologue
函数开头惯例指令序列(用于建立该函数的工作栈帧)：
- push rbp
- mov rbp，rsp
- sub rsp，0x20 


#### 函数 epilogue
函数结束惯例指令序列(用于撤销该函数的工作栈帧,并返回调用处)：
- `leave` 等同于 `mov rsp, rbp` 和 `pop rbp`
- `ret` 等同于 `pop rip`


### 栈帧 stack frames
下面以调用函数过程，介绍栈帧变化，分为几个阶段：
- call foo 之前的初始状态
- call foo 指令执行后
- 执行 foo prologue 语句
- 执行 foo epilogue 语句
- ret


#### 初始情况
假设有指令序列：

```S
0x00400597 e8aaffffff call 0x400546
0x0040059c bf00000000 mov edi, 0
0x004005a1 e89afeffff call sym.imp.exit
```

执行第一条 call 指令前，寄存器和堆栈值分别为：
- 寄存器：
rdi: 0x7ffe89cd1cc0 char* -> Hello, world!
rsp: 0x7ffe89cd1cc0
rbp: 0x7ffe89cd1cd0
rip: 0x00400597

- 堆栈：
0x7ffe89cd1cc0 = 0x77202c6f6c6c6548
0x7ffe89cd1cc8 = 0x00000021646c726f
0x7ffe89cd1cd0 = 0x00000000004005b0

#### 执行第一条 call 指令后
寄存器和堆栈值会发生变化（将call的下一条指令地址压入当前栈顶）：

- 寄存器变化
rdi: 0x7ffe89cd1cc0 char* -> Hello, world!
rsp: 0x7ffe89cd1cb8
rbp: 0x7ffe89cd1cd0
rip: 0x00400546

- 堆栈变化
0x7ffe89cd1cb8 0x000000000040059c
0x7ffe89cd1cc0 0x77202c6f6c6c6548
0x7ffe89cd1cc8 0x00000021646c726f
0x7ffe89cd1cd0 0x00000000004005b0

此时指令序列变为下列：
```S
0x00400546 55 push rbp
0x00400547 4889e5 mov rbp, rsp
0x0040054a 4883ec10 sub rsp, 0x10
0x0040054e 48897df8 mov qword [rbp - 8], rdi
0x00400552 488b45f8 mov rax, qword [rbp - 8]
0x00400556 4889c7 mov rdi, rax
0x00400559 e8d2feffff call sym.imp.puts
0x0040055e 90 nop
0x0040055f c9 leave
0x00400560 c3 ret
```
#### 执行函数 prologue 语句

执行 `0x00400546 55 push rbp` 后，变化如下：

寄存器变化：
rdi: 0x7ffe89cd1cc0 char* -> Hello, world!
rsp: 0x7ffe89cd1cb0
rbp: 0x7ffe89cd1cd0
rip: 0x00400547

堆栈变化：
0x7ffe89cd1cb0 0x00007ffe89cd1cd0
0x7ffe89cd1cb8 0x000000000040059c
0x7ffe89cd1cc0 0x77202c6f6c6c6548
0x7ffe89cd1cc8 0x00000021646c726f
0x7ffe89cd1cd0 0x00000000004005b0

可见push 操作会使: esp <= esp - 8; eip <= 下一条指令地址 ；ebp 不变。

执行`mov rbp,rsp` 会改变当前栈帧，由于上面几条语句 rsp 在不断变小（intel x86/amd64），所以当前栈帧从视觉上是上移了一块。

之后语句`sub rsp,0x10`会使 rsp 更小一些，那时此栈帧大小：

The size of stack frame = rbp-rsp

具体数值：
```S
● rdi: 0x7ffe89cd1cc0 char* -> Hello, world!
● rsp: 0x7ffe89cd1ca0
● rbp: 0x7ffe89cd1cb0
● rip: 0x0040054e

0x7ffe89cd1ca0 <uninitialized data>
0x7ffe89cd1ca8 <uninitialized data>
0x7ffe89cd1cb0 0x00007ffe89cd1cd0
0x7ffe89cd1cb8 0x000000000040059c
0x7ffe89cd1cc0 0x77202c6f6c6c6548
0x7ffe89cd1cc8 0x00000021646c726f
0x7ffe89cd1cd0 0x00000000004005b0
```

#### 执行函数结尾语句

```S
0x00400546 55 push rbp
0x00400547 4889e5 mov rbp, rsp
0x0040054a 4883ec10 sub rsp, 0x10
0x0040054e 48897df8 mov qword [rbp - 8], rdi
0x00400552 488b45f8 mov rax, qword [rbp - 8]
0x00400556 4889c7 mov rdi, rax
0x00400559 e8d2feffff call sym.imp.puts
0x0040055e 90 nop
0x0040055f c9 leave (mov rsp, rbp;pop rbp)
0x00400560 c3 ret 
```

跳过leave之前的语句，下面看看执行leave语句前的情况
```S
● rdi: 0x7ffe89cd1cc0 char* -> Hello, world!
● rsp: 0x7ffe89cd1ca0
● rbp: 0x7ffe89cd1cb0
● rip: 0x0040055f

0x7ffe89cd1ca0 <uninitialized data>
0x7ffe89cd1ca8 0x00007ffe89cd1cc0
0x7ffe89cd1cb0 0x00007ffe89cd1cd0
0x7ffe89cd1cb8 0x000000000040059c
0x7ffe89cd1cc0 0x77202c6f6c6c6548
0x7ffe89cd1cc8 0x00000021646c726f
0x7ffe89cd1cd0 0x00000000004005b0
```

执行leave语句，相当于两条指令：`mov rsp, rbp; pop rbp`。执行之后的具体变化：
```S
● rdi: 0x7ffe89cd1cc0 char* -> Hello, world!
● rsp: 0x7ffe89cd1cb8
● rbp: 0x7ffe89cd1cd0
● rip: 0x00400560

0x7ffe89cd1ca0 <uninitialized data>
0x7ffe89cd1ca8 0x00007ffe89cd1cc0
0x7ffe89cd1cb0 0x00007ffe89cd1cd0
0x7ffe89cd1cb8 0x000000000040059c
0x7ffe89cd1cc0 0x77202c6f6c6c6548
0x7ffe89cd1cc8 0x00000021646c726f
0x7ffe89cd1cd0 0x00000000004005b0
```

再执行ret指令，ret指令相当于`pop rip`,之后的情况如下：

```S
rdi: 0x7ffe89cd1cc0 char* -> Hello, world!
● rsp: 0x7ffe89cd1cc0
● rbp: 0x7ffe89cd1cd0
● rip: 0x0040059c

0x7ffe89cd1ca0 <uninitialized data>
0x7ffe89cd1ca8 0x00007ffe89cd1cc0
0x7ffe89cd1cb0 0x00007ffe89cd1cd0
0x7ffe89cd1cb8 0x000000000040059c
0x7ffe89cd1cc0 0x77202c6f6c6c6548
0x7ffe89cd1cc8 0x00000021646c726f
0x7ffe89cd1cd0 0x00000000004005b0
```

### Endianness（端序）

上面例子中，二进制文件在内存中存放的顺序遵循的是 little-endian 字节序。例如有堆栈数据：
```S
0x7ffe89cd1ca0 <uninitialized data>
0x7ffe89cd1ca8 0x00007ffe89cd1cc0
0x7ffe89cd1cb0 0x00007ffe89cd1cd0
0x7ffe89cd1cb8 0x000000000040059c
0x7ffe89cd1cc0 0x77202c6f6c6c6548
0x7ffe89cd1cc8 0x00000021646c726f
0x7ffe89cd1cd0 0x00000000004005b0
```

0x7ffe89cd1cc0 addresses the byte ‘0x48’,
0x7ffe89cd1cc1 addresses the byte ‘0x65’,
...
0x7ffe89cd1ccc addresses the byte ‘0x21’

假设我们使用 radare2 打开一个二进制文件，然后执行下面两条语句可以看到：
```S
[0x00001060]> pxq 8 @ rbp
0x00000000  0x00010102464c457f                       .ELF....
[0x00001060]> px 8 @ rbp
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x00000000  7f45 4c46 0201 0100                      .ELF....
[0x00001060]> 

```

## References

: External resources
0x11: Compiling source
Working with Hexadecimal: https://learn.sparkfun.com/tutorials/hexadecimal
High-level article on compilers: https://en.wikipedia.org/wiki/Compiler
0x12: Looking at the Binary
What is File Magic?: https://en.wikipedia.org/wiki/Magic_number_(programming)#Format_indicator
Commands used: file, strings, xxd, less, objdump, grep,
For help with these commands, just use `man <command>` to show the manual pages.
For information on how linux PIPES (“|”) work, check out:
https://superuser.com/questions/756158/what-does-the-linux-pipe-symbol-do
0x20: Memory and Registers
Subject matter learned in Computer Organization: processor pipelining, memory types vs speed, Instruction decoding.
High-level Register reference: https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Overall/register.html
0x21: Memory
Virtual-Physical memory mapping learned in OS
High-level overview of Linux Memory Management: http://www.thegeekstuff.com/2012/02/linux-memory-management/
0x22: Process memory layout
Elf File format: https://en.wikipedia.org/wiki/Executable_and_Linkable_Format
Process memory overview: http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/
Take note that the above link reverses address direction (high-on-top) whereas the better way is (low-on-top)
0x23 Registers:
Learned about memory timings and CPU caching in Comp Org
Register reference: https://wiki.cdot.senecacollege.ca/wiki/X86_64_Register_and_Instruction_Quick_Start
Syscall table: http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/

0x31: Assembly Instructions
High-level overview of Assembly: http://ian.seyler.me/easy_x86-64/
x86 Instruction reference: https://www.aldeid.com/wiki/X86-assembly#Pages_in_this_category
Video tutorial of basic assembly: https://www.youtube.com/watch?v=busHtSyx2-w
0x32: Function Prologue and Epilogue
Look here for which registers are preserved across function/syscalls:
https://stackoverflow.com/questions/18024672/what-registers-are-preserved-through-a-linux-x86-64-function-call
Stack frame layout on x86-64: http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64
Ridiculously drawn (with terrible audio) but accurate: https://www.youtube.com/watch?v=kSgrKtA0rJM
0x33: Stack Frames
Use `man ascii` to see what ordinal values correspond to which letters of the alphabet! (or visit a page like
http://www.ascii-code.com/)
0x34: Quick note about Endianness
More about endianness: https://en.wikipedia.org/wiki/Endianness
0x40: Radare2
Official radare2 repo (with install instructions): https://github.com/radare/radare2
My custom radare2 Cheat Sheet:
https://docs.google.com/document/d/1our_fcFcufIJ13QsZoDuGOEBqftF6o0zEkDsqzAy43U/edit?usp=sharing
Unofficial radare2 Cheat Sheet (a little outdated):
https://github.com/pwntester/cheatsheets/blob/master/radare2.md