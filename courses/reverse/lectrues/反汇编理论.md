# 反汇编理论

代码经过编译、汇编、链接中的一个或几个过程生成可执行程序。反汇编就是汇编的你过程，目标是获得源代码。

Why？ 反汇编的用途意义：
- 分析恶意软件
- 分析闭源软件的漏洞
- 分析闭源软件的互操作性
- 验证编译器性能准确性
- 调试时显示程序指令

反汇编的困难在于：
- 编译过程会造成（源代码）损失
  - 机器语言中没有变量或函数名
  - 变量类型信息只有通过数据的用途来确定。
- 编译属于多对多操作
  - 意味着源程序可以通过多种不同形式转换为汇编语言，而机器语言也可以通过多种方式转换为源程序。编译一个文件，立即反编译得到的也不是一样的源文件。
- 反编译器非常依赖于语言和库
  - 生成C代码的反编译器处理delphi久得到奇怪结果
  - 对windows api一无所知的反编译器得到的结果也会很奇怪
- 想准确反编译一个二进制文件需要近乎完美的反汇编能力


## How？如何反汇编？

### 需要考虑的问题
综合：
- 一个文件是不是可执行文件？有没有反汇编的可能或需要？
- 二进制文件是否有格式？（elf、pe、mach-o...）

有关指令和指令集：
- 一个二进制文件的指令部分从文件的哪个位置开始？到哪里结束？
- 二进制文件中指令如何识别？（数据or指令？定长or变长？控制指令？）

编译方面：
- 文件中采用的编译方法、参数对程序的影响？
- 名称改编的方式（例如C++标准中没有对重载函数的名称改编进行规定，编译器自行决定，那么如何理解他们？）

链接方面：
- 文件使用哪种方法进行链接？（静态、动态、结合方式）
- 静态方式链接的文件，链接了哪些库？
- 链接的库函数中哪些是“二进制函数”？


### 基本的反汇编算法

- 第一步 确定进行反汇编的代码区域。
  - 通常指令和数据混在一起，要区分他们。这就要是被文件格式，例如 PE、ELF，他们自有机制来确定文件中包含的代码和代码入口点的部分。通常表现为层级文件头形式。
- 第二步 确定指令的起始位置（代码区的开始位置），接着要读区该地址包含的值并执行一次表查找，将二进制操作吗的值与它的汇编助记符对应起来。
- 第三步 获取指令并解码任何所需的操作数后，对它的汇编语言等价形式进行格式化，并将其汇编代码输出。可能有多种格式，例如x86的汇编码有 Intel 和 AT&T两种
- 第四步 输出一条指令后，继续反汇编下一条指令，并重复上面的过程，直到反汇编万所有文件中指令。

有很多算法可以用于确定从何处开始反汇编？如何选择下一条反汇编质量？如何区别代码和数据？如何确定何时完成对最后一条指令的反汇编？

两种基本算法：
- 线性扫描 linear sweep
- 递归下降 recursive descent

#### 线性扫描反汇编

原理很好理解：找到一条指令的头尾；找下一条指令。这里的关键在于何处是程序中指令开始的地方？每条指令的长短不同，如何判断一条指令结束？

- 如何确定指令起始位置
  - 常见办法是假设程序头部标为代码的节（例如 .text)全部为指令
  - 从代码节第一条开始反汇编，直到最后一条。
  - 不理解分支、循环等结构。

算法特点：
- 从算法上来看，一旦能够准确确定代码起始位置，这种算法很适合固定长度指令集（MIPS）代码的反汇编。
- 能够覆盖代码段所有内容。
- 不能区别代码段中的数据。例如有的编译器会对各种跳转、取数做成一个跳转表（例如switch多路分支结构、指针数组），这个跳转表是一种数据结构，不是指令，在线性扫描算法中不会理解这部分，只能将其转换为指令。

使用线性扫描算法的工具有
- GNU gdb
- WinDbg
- objdump

#### 递归下降反汇编

这种方法强调控制流的概念。控制流根据一条指令是否被另一条指令引用来决定是否对其进行汇编。

根据指令对CPU指令指针的影响，可将指令分为：
- 顺序流指令
  - 将执行权交给下一条指令，即CPU指令指针（PC）指向下一条指令。
- 条件分支指令
  - 这类指令提供了两条执行路径。
  - 条件为假，此条指令视为顺序流指令，继续执行后续语句
  - 条件为真，此条指令要修改PC，但由于静态分析不能预知条件为真，所以对这条指令的反汇编要置后处理。即指令操作码后的地址部分不能及时填入。
- 无条件分支指令
  - 无条件分支指令一定会修改 PC，那么紧跟在此指令后的指令的地址若不等于该指令中的地址，那就没必要反汇编了。
  - 递归下降算法会将无条件跳转指令后的地址列入需要反汇编的地址列表中。
  - 无条件跳转指令有的会给反汇编器造成分析困难，例如调整值为动态计算结果（如 jmp eax），静态分析无法知道 eax 当前内容。
- 函数调用指令
  - 与无条件跳转指令情况类似。区别在于函数执行完毕后，执行权交给函数调用语句后的指令。
  - 调用指令的目标地址，被此类反汇编器放入延迟进行反汇编的地址列表。而紧跟函数调用指令的后续语句按线性扫描方式反汇编。
  - 从被调用函数返回时，若程序运行出现异常，递归下降方法可能会失败。例如函数中代码篡改了返回地址。当然，线性扫描也不一定能正确处理这一问题。

- 返回指令
  - 有时函数返回指令没有提供下来将要执行的指令地址（例如 x86 ret），若程序正在执行，则可以从运行时堆栈的顶部获得一个地址，并从这个地址开始恢复执行指令。但反汇编器不具备访问栈的能力，因此反汇编过程会突然停止。
  - 此时，递归下降反汇编器会转而处理之前搁置在延迟反汇编地址列表中的内容。这也是这种方法得名的依据。


算法特点：
- 能够区分代码和数据。作为一种基于控制流的算法，很少将数据值错误认为是代码。
- 缺点是，无法处理间接代码路径，如利用指针表来查找目标地址的跳转或调用。
- 通过采用一些用于识别指向代码的指针的启发式方法，这类反汇编器可以提供所有代码，并清楚的区分代码与数据。

使用递归下降反汇编算法的工具有：
- IDA Pro


### 反汇编具体操作步骤

应用IDA pro或其他工具前，最好对待分析的文件有所认识。例如这个文件是什么文件？

#### 了解文件类型
不要以后缀名判断文件类型。可以使用`file`等工具进行查看是一种好的方法。 这个工具会检查：
- 文件中特定字段的标签值（也称为幻数 magic），来确定文件类型。
- 识别ASCii字符串
- 判断文件结构是否为已知文件结构

例如：PE文件（MS-DOS） 的幻数为“ 4D 5A ”MZ，JAVA的为 0xcafebabe，JPEG的为“FF D8”

file的幻数文件（magic file）中存放了已知的幻数。通常位置在 /usr/share/file/magic 或 /usr/share/misc/magic 或 /etc/magic。具体的可以参考file文档。

当然，file 工具也可能出错，比如某个文件包含了某种文件格式的标记，或者特意将文件的幻数进行修改。

**逆向分析时，首先要借助多种工具查看文件类型，必要时要手动查看。**

- PE tools是分析windows 系统中可执行文件的工具。
- PEiD 也是分析windows 系统中可执行文件的工具。

#### 了解文件基本信息
这时需要对文件进行摘要分析。

可以使用的工具有 
- nm，可以列举目标文件中的符号。
- ldd，可以解析文件引用的库函数。
- otool，与ldd类似的OS X工具，`otool -l <binary file name>` 可以解析文件引用的库函数。
- dumpbin，是Windows visual studio中工具，也可以解析文件引用的库函数。
- objdump 多样化功能的工具，是GNU binutils 工具集中的一个。
- readelf，可用于解析elf文件，功能类似objdump，但readelf不依赖libbfd库。
- c++filt，可用于分析编译器对重载函数的改编名，如果名称合法则输出原始函数名。如果无法识别就原样输出函数名。


##### nm 工具
nm 可以列举目标文件中的符号。默认输出结果是所有的函数和全局变量名。符号分为几种：
- 未定义符号（U），通常为外部符号引用；
- 在文本部分定义的符号（T），通常为函数名；
- 在文本部分定义的局部符号（t）；
- 已初始化的数据值（D）；
- 未初始化的数据值（C）；
- 发现引用的二进制文件名（b）；
- 发现引用的二进制文件名（B）。
- 括号内，大写的为全局符号；小写的为局部符号。

##### objdump 工具
objdump 多样化功能的工具，是GNU binutils 工具集中的一个。

可以显示下列与目标文件相关的信息：
- 节头部，程序每个节的摘要信息
- 专用头部，程序内存分布信息、运行时加载器所需的其他信息，例如库函数列表
- 调试信息，提取文件中的任何调试信息
- 符号信息，类似nm所提取的符号信息
- 反汇编代码，objdump 对代码部分执行线性扫描反汇编，对x86指令集可生成 AT&T 或 Intel 汇编语法，并存到文件中。这样的文本文件成为“反汇编死代码清单（dead listing）”，这个文件很难有效导航，也无法以一致且唔错方式被修改。

objdump 依靠二进制文件描述符库 libbfd 来访问目标文件。libbfd 支持文件格式有 elf、pe等。
#### 检查文件结构，深度了解文件

可用的工具：
- strings：输出文件包含的字符串，默认是至少包含连续4个可打印 ASCII 字符的字符串会被输出。


strings工具在使用时需要注意：
- 默认仅搜索可加载的、经初始化的部分，使用参数 -a 可以扫描全文件。
- 不会指出字符串在文件中的位置，使用 -t 可以指出字符所在的偏移。
- 对使用其他字符集（非 ascii），可以使用 -e 参数可搜索广泛字符


注意：
- 不要根据字符串输出判断程序功能，可能掉入陷阱。例如 strings 的输出。
- 文件包含的字符串，不一定会被使用，可能是无意或有意引入无用字符串。

#### 反汇编文件

大多数工具仅能对有已知结构的二进制文件进行分析和反汇编。

x86指令集反汇编工具：
- 流式反汇编工具：可用于分析（1）普通有已知结构的二进制文件（elf、pe、mach-o）；（2）网络流量中的shellcode；（3）无结构的ROM镜像。
  - ndisam
  - diStorm


## 其他知识

### 编译
一个目标文件不能出现两个名字完全相同的函数。

- 名称改编 name mangling
为支持重载，编译器将描述函数参数类型的信息合并到函数的原始名称中，从而为重载函数生成唯一的名字。这个过程称为名称改编（name mangling）。


### 链接
可执行文件可以采用的链接方式有：
- 静态链接：将应用程序的目标文件和所需的库文件组合起来生成一个可执行文件。例如 `gcc -o example_static example.c --staic`
  - 优点：函数调用快、不需要重定位库代码、发布更容易；
  - 缺点：可执行文件大；库组件若变化，升级不便，需要全部重新链接；逆向分析也比较难。
- 动态链接：链接时不复制库，只需将库（so文件或dll文件）和资源文件的引入（调用方式or地址）插入到最终可执行文件中。`gcc -o example_dynamic example.c`
  - 优点：最终文件小、升级库函数容易、速度快。
  - 缺点：加载过程复杂，因为是运行时加载，所以需要先定位库并加载到内存，而不是加载一个静态链接文件；另一缺点是发布时需要提供所有库和可执行文件，如果缺少某个就会不能执行。
- 静、动态结合链接。


## 参考资料

- [OPENRCE](http://www.openrce.org) 
- [RCE forum](http://www.woodmann.org)
- Ilfak Blog
- Hex-Rays forum