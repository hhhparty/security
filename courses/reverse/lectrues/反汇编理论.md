# 反汇编理论

代码经过编译、汇编、链接中的一个或几个过程生成可执行程序。反汇编就是汇编的你过程，目标是获得源代码。

Why？ 反汇编的用途意义：
- 分析恶意软件
- 分析闭源软件的漏洞
- 分析闭源软件的互操作性
- 验证编译器性能准确性
- 调试时显示程序指令

反汇编的困难在于：
- 编译过程会造成（源代码）损失
  - 机器语言中没有变量或函数名
  - 变量类型信息只有通过数据的用途来确定。
- 编译属于多对多操作
  - 意味着源程序可以通过多种不同形式转换为汇编语言，而机器语言也可以通过多种方式转换为源程序。编译一个文件，立即反编译得到的也不是一样的源文件。
- 反编译器非常依赖于语言和库
  - 生成C代码的反编译器处理delphi久得到奇怪结果
  - 对windows api一无所知的反编译器得到的结果也会很奇怪
- 想准确反编译一个二进制文件需要近乎完美的反汇编能力


## How？如何反汇编？

### 基本的反汇编算法

- 第一步 确定进行反汇编的代码区域。
  - 通常指令和数据混在一起，要区分他们。这就要是被文件格式，例如 PE、ELF，他们自有机制来确定文件中包含的代码和代码入口点的部分。通常表现为层级文件头形式。
- 第二步 确定指令的起始位置（代码区的开始位置），接着要读区该地址包含的值并执行一次表查找，将二进制操作吗的值与它的汇编助记符对应起来。
- 第三步 获取指令并解码任何所需的操作数后，对它的汇编语言等价形式进行格式化，并将其汇编代码输出。可能有多种格式，例如x86的汇编码有 Intel 和 AT&T两种
- 第四步 输出一条指令后，继续反汇编下一条指令，并重复上面的过程，直到反汇编万所有文件中指令。

有很多算法可以用于确定从何处开始反汇编？如何选择下一条反汇编质量？如何区别代码和数据？如何确定何时完成对最后一条指令的反汇编？

两种基本算法：
- 线性扫描 linear sweep
- 递归下降 recursive descent

