# ARM 指令速查表

## 指令
指令大致可分为下列类型：
- 数据处理指令
- 内存访问（load and stores to memory)
- 控制流
- 系统指令

### 数据处理指令
#### 数据移动

|功能|指令格式|说明|备注|
|-|-|-|-|
|数据传递|MOV Rd，Op2| Rd = Op2|寄存器间、立即数|
|数据取反传递|MVN Rd,Op2|Rd = -Op2|寄存器间、立即数|


#### 加减乘除

|功能|指令格式|说明|备注|
|-|-|-|-|
|加法|ADD Rd, Rn, Op2|Rd = Rn+Op2||
|带进位加法|ADC Rd, Rn, Op2|Rd = Rn+Op2+CFlag||
|减法|SUB Rd,Rn,Op2|Rd = Rn - Op2||
|带进位减法|SBC Rd,Rn,Op2|Rd = Rn - Op2 - CFlag||
|反转减法|RSB Rd,Rn,Op2|Rd = Op2 - Rn||
|反转带进位减法|RSC Rd,Rn,Op2|Rd = Op2 -Rn - CFlag||
|乘法-32位|MUL Rd，Rm，Rs|Rd = Rm * Rs||
|乘法后累加-32位|MUL Rd，Rm，Rs，Rn|Rd = Rm * Rs + Rn||
|无符号乘法-64位|UMULL RdLo，RdHi，Rm，Rs|（RdLo，RdHi）= Rm * Rs||
|无符号乘法后累加-64位|UMLAL RdLo，RdHi，Rm，Rs|（RdLo，RdHi）= Rm * Rs+（RdLo，RdHi）||
|有符号乘法-64位|SMULL RdLo，RdHi，Rm，Rs|（RdLo，RdHi）= Rm * Rs||
|有符号乘法后累加-64位|SMLAL RdLo，RdHi，Rm，Rs|（RdLo，RdHi）= Rm * Rs+（RdLo，RdHi）||

#### 逻辑运算

|功能|指令格式|说明|备注|
|-|-|-|-|
|与|AND Rd,Rn,Op2|Rd = Rn & Op2||
|或|ORR Rd,Rn,Op2|Rd = Rn | Op2||
|位清零|BIC Rd,Rn,Op2|Rd = Rn & ～Op2|可视为逻辑非|
|异或|EOR Rd,Rn,Op2|Rd = Rn ^ Op2||

#### 比较运算

|功能|指令格式|说明|备注|
|-|-|-|-|
|比较|CMP Rn,Op2|Rn - Op2|影响ZFlag，相等时ZFlag = 1|
|负数比较|CMN Rn,Op2|Rn - （-Op2）|影响ZFlag，相等时ZFlag = 1|
|测试相等|TEQ Rn,Op2|Rn & Op2|做与运算，影响？？？|
|测试|TST Rn,Op2|Rn ^ Op2|做异或运算，影响？？？|


### 内存访问指令

#### 单寄存器读写

|功能|指令格式|说明|备注|
|-|-|-|-|
|读数到寄存器|LDR Rd，内存地址|将内存地址指向数据传到Rd|按字 32bit|
|存数到存储器|STR Rd，内存地址|将寄存器Rd中数据存放到内存地址指向位置|按字 32bit|
|读数到寄存器|LDRB Rd，内存地址|将内存地址指向数据传到Rd|按低字节 8bit|
|存数到存储器|STRB Rd，内存地址|将寄存器Rd中数据存放到内存地址指向位置|按字节 8bit|
|读数到寄存器|LDRH Rd，内存地址|将内存地址指向数据传到Rd|按半字 16bit|
|存数到存储器|STRH Rd，内存地址|将寄存器Rd中数据存放到内存地址指向位置|按半字 16bit|


## 伪指令

伪指令的作用是辅助指令集完成数据操作、比较等等。

伪指令从来源（编译器）看，分为：
- GNU 伪指令，习惯以`.`开头
- ARM 伪指令

### 程序部署类

|功能|    指令格式|    说明|    备注|
|-|-|-|-|
|声明区域  |  `AREA test,CODE,READONLY`   | 声明区域段，数据区、代码区||
|声明代码16bit或32bit  |  `CODE16` 或 `CODE32`|    声明下面的代码是32位或16位，注意不是切换arm和thumb模式||
|指定程序的入口点|    `ENTRY` |   一个完整程序至少有一个（或多个）入口点，一个源文件中只有一个。||
|指定程序结尾 |   `END`  |  ||
|为常量或标号定义等量字符名 |   `字符名称  EQU   常量或标号`|||
|声明全局标号 |   `EXPORT  标号名称`  |  使某个标号可以在其他文件被使用，可以使用`GLOBAL`代替，标号区分大小写[WEAK] 声明其他同名的标号又闲鱼该标号被引用。||
|引入其他文件中标号|    `IMPORT` |   相当于静态引用，无论是否使用都会在执行前被加入当前文件中。||
|引入其他文件中标号|    `EXTERN`|    相当于动态引用||
|包含某个文件|    `GET "**.s"` |    引入某个源文件，相当于c中的#include||
|对寄存器起别名 |   `别名  RN  寄存器`|    主要是为了便于记忆和交流||

示例：

```s
    AREA test, CODE , READONLY
    CODE32
    GET 'a.s'
pwdReg RN R3
    ENTRY
MYNAME EQU 'HHH' ;注意有些汇编器对于自定义名称需要顶行写，否则出错。
start
    MOV R1,#0x0f
    MOV pwdReg,#0x1234
    ...
    END

```


### 符号命名要求

- 符号区分大小写
- 符号在其作用范围内需要唯一，不能重名定义
- 自定义的符号名不能与系统（编译器）使用的一样
- 符号名不能与指令名相同
- 注意有的汇编工具对符号名要求顶行写。

### 变量定义伪指令

ARM/Thumb 汇编程序的变量有三类：
- 数字变量，一般为32位的整数，无符号数范围 0～$2^{32}$，有符号数范围 $-2^{32}$～$2^{32}-1$
- 逻辑变量:{TRUE ，FALSE}
- 字符串变量


|功能|指令格式|说明|备注|
|-|-|-|-|
|定义全局数字变量/逻辑变量/字符串变量|`GBLA/GBLL/GBLS <变量名>`| 定义某个符号为一个全局变量|全局就是整个文件，全局变量放在.data段|
|定义局部数字变量/逻辑变量/字符串变量|`LBLA/LBLL/LBLS <变量名>`| 定义某个符号为一个局局变量|局部是指某个过程,局部变量放在堆栈中|
|设置数字变量/逻辑变量/字符串变量的值|`SETA/SETB/SETS <变量名> <变量的值>`| 指定某个变量的值|赋值|
|将寄存器列表命名为某个变量名为起始的列表|`列表名称 RLIST {R0-R5,R8,R10}`| 为了方便访问，类似定义了一个数组||


示例：
```s
    AREA test, CODE , READONLY
    CODE32
    GET 'a.s'
    GBLA myVar1
    GBLL myFlag
    LBLS myStr
myVar1 SETA 0x10
myFlag SETL {TRUE}
myList RLIST {R1,R2,R4-R6}
myStr SETS "Hello LLL"
    ENTRY
start
    MOV R1,#0x0f
    MOV pwdReg,#0x1234

    LDMIA R2, myList ;将R2 指向的内存数据依次存放到 R1，R2，R4，R5，R6.
    ...
    END

```

### 算数伪指令

|功能|指令格式|说明|备注|
|-|-|-|-|
|加法|`+`|||
|减法|`-`|||
|乘法|`*`|||
|除法|`/`|||
|求余|`MOD`|||


### 按位逻辑伪指令

|功能|指令格式|说明|备注|
|-|-|-|-|
|与|`AND`|||
|或|`OR`|||
|非|`NOT`|||
|异或|`EOR`|||

### 移位伪指令

|功能|指令格式|说明|备注|
|-|-|-|-|
|循环左移|`ROL`|||
|循环右移|`ROR`|||
|逻辑左移|`SHL`|||
|逻辑右移|`RHL`|||

### 表达式中的伪指令

|功能|指令格式|说明|备注|
|-|-|-|-|
|等于|`=`|||
|大于|`>`|||
|小于|`<`|||
|大于等于|`>=`|||
|小于等于|`>=`|||
|不等于|`/=`|||
|不等于|`<>`|||

|功能|指令格式|说明|备注|
|-|-|-|-|
|与|`LAND`|按表达式计算||
|或|`LOR`|||
|非|`LNOT`|||
|异或|`LEOR`|||

### 寄存器操作伪指令

|功能|指令格式|说明|备注|
|-|-|-|-|
|将内存数据存放到寄存器|`LDR R0，=<立即数或变量名>`| 大范围寻址到寄存器|伪指令格式与指令格式不同，有事代替 `MOV` `MVN`|
|将内存数据存放到寄存器|`ADR R0，=<立即数或变量名>`| 小范围（0～255）寻址到寄存器|伪指令格式与指令格式不同|
|将内存数据存放到寄存器|`ADRL R0，=<立即数或变量名>`| 中范围寻址到寄存器|伪指令格式与指令格式不同|


示例：
```s
    AREA test, CODE , READONLY
    CODE32
    GBLS myStr
myVar1 SETA 0x10
    LDR R1, =myVar1

    ENTRY
start
    MOV R1,#0x0f
    MOV pwdReg,#0x1234

    LDMIA R2, myList ;将R2 指向的内存数据依次存放到 R1，R2，R4，R5，R6.
    ...
    END

```

### 数据定义伪指令
|功能|指令格式|说明|备注|
|-|-|-|-|
|按字节连续分配内存区域| `[变量名称]  DCB <数值 [,数值2，数值3...]>`|定义首地址为变量名称的一块连续内存区域，按字节存放数值||
|按半字连续分配内存区域| `[变量名称]  DCW <数值 [,数值2，数值3...]>`|定义首地址为变量名称的一块连续内存区域，按半字存放数值||
|按字连续分配内存区域| `[变量名称]  DCD <数值 [,数值2，数值3...]>`|定义首地址为变量名称的一块连续内存区域，按字存放数值||
|按浮点双精度连续分配内存区域| `[变量名称]  DCFD <数值 [,数值2，数值3...]>`|定义首地址为变量名称的一块连续内存区域，按浮点双精度（64位）存放数值||
|按浮点单精度连续分配内存区域| `[变量名称]  DCSD <数值 [,数值2，数值3...]>`|定义首地址为变量名称的一块连续内存区域，按浮点单精度（64位）存放数值||
|按8字节连续分配内存区域| `[变量名称]  DCQ <数值 [,数值2，数值3...]>`|定义首地址为变量名称的一块连续内存区域，按8字节存放数值||
|连续分配内存区域并初始化为0| `[变量名称]  SPACE <长度>`|定义首地址为变量名称的一块连续内存区域，大小为指定长度个字节，这些字节初始化为0||
|定义一个结构体的首地址| `[名称]  MAP <地址值>`|定义一个结构体的首地址为，按浮点单精度（64位）存放数值|MAP 可以用 `^` 代替|
|定义一个结构体内的每个数据项| `[名称]  FIELD <长度>`|定义一个结构体内的数据项，数据项长度为指定长度*字节|FIELD 可以用`#`代替|