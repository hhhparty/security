# 安全检查列表
https://www.starlab.io/blog/the-linux-security-hardening-checklist-for-embedded-systems

https://www.embedthis.com/blog/posts/stories/iot-developer-security-checklist.html

https://embeddedcomputing.com/technology/iot/wireless-sensor-networks/security-checklist-for-iot-sensors

qt.io/embedded-development-talk/how-to-use-the-best-security-for-your-embedded-system

https://docs.microsoft.com/en-us/windows-hardware/drivers/driversecurity/driver-security-checklist

https://docs.microsoft.com/en-us/azure/iot-develop/concepts-azure-rtos-security-practices

## 场景1: 组织层面

## 

不要认为嵌入式设备太笨或太隐蔽而不会受到损害——不要认为嵌入式安全是理所当然的。
在连接到本地网络之前，完全配置和加固连接的嵌入式设备。
让设备在私有、隔离的网络上进行开发——开发人员的黑客攻击可能会从外部或内部促成不受欢迎的破解。
盘点并了解给定设备或嵌入式操作系统上可用的端口和服务。仅启用您的应用程序真正需要的那些，并禁用其余的。
考虑将嵌入式设备放置在公司防火墙之外；让他们通过选定的端口访问公司网络资源，或者更好的是，通过 SSL（Web 界面）、SSH 或 VPN 等安全服务。
特别注意保护嵌入式设备上的无线接口（例如 802.11b）：使用协议固有的可用安全性；强化接入点（例如，通过 MAC 地址限制无线连接）；如果可能，将接入点放置在防火墙之外。
预测部署设备上未来的软件更新需求，以将安全补丁（通过 OSGI 等）应用到闪存或其他可重写存储介质上。
对于远程更新、下载和数据记录，请考虑使用仅拉式访问，其中设备间歇性地连接到“电话主页”，而不是将数据推送到始终连接的设备上，从而可以利用这些设备。
开始考虑嵌入式设备，就像网络上的任何其他企业资产一样。


隐私
是否所有数据都进入服务器，用户是否可以选择让所有个人和使用数据掌握在自己手中？ 
数据格式/API 是否已记录/公开可用，允许用户在没有应用程序/云服务的情况下使用他们的数据？
您是否有删除存储数据的政策？用户可以请求提前超时吗？用户可以请求本地存储（他们的家用计算机）的数据吗？
用户是否知道谁可以访问他们的个人和设备数据？
（第 3 方公司、数据研究公司、市场营销、IT 管理员、技术支持、开发人员、用户、用户的朋友/家人等）对于不同的数据消费者是否存在具有不同权限的不同角色？
开发人员（或其他人）是否可以进行调试？如果是这样，开发人员（或其他人）是否也可以看到用户的个人信息（即电子邮件地址）以及设备信息？设备数据是否按照匿名用户 ID 存储，个人信息是否单独存储？
如果是可穿戴设备，该设备是否会发送数据以使其（和用户）可被嗅探器识别（即 MAC 地址）？
安全
您的设备是否允许/需要密码才能从设备获取信息？从应用程序？从服务器？这些密码多久需要一次？用户可以设置超时吗？
授权用户是否会在超时后自动注销？这需要多长时间？
数据是你备份的吗？是否保护到与实时数据相同的级别？备份会过期还是无限期保留？
您能否检查设备、应用程序和/或服务器是否被黑客入侵？你有什么工具来检测入侵？这些工具可以用作安全审计的一部分吗？
您有办法将设备验证为您的设备吗？您可以验证使用该设备的用户吗？您是否在出厂前将设备身份验证和加密密钥添加到数据库以防止复制？
您的固件更新是否安全、签名和验证？（Atmel 有一篇很好的白皮书讨论了固件更新可能出错的所有方式。）您的设备可以复制吗？
贵公司是否有保护其服务器免受入侵的程序？它是否有备份以防损坏？是否定期审核备份？
您是否在数据通过网络传输时（从设备到应用程序、从应用程序到服务器、从服务器到备份、从服务器到用户界面）加密数据？您是否采取了其他措施来降低用户数据在网络上被截获或修改的风险？对于不同的信息，您是否有不同的数据路径？（例如，在 TCP/IP 中，您可以通过一个端口发送您的身份验证，并通过另一个端口发送用户数据，因此端口嗅探器必须更加努力地捕获流。）
透明度
您是否有明确的政策来限制对数据的访问？不同的信息（个人与数据）是否有不同的安全处理？
您的安全和隐私政策解释清楚了吗？您的服务条款是否易于总结并呈现给用户？（请参阅服务条款；未阅读 以了解使用户更轻松的一些方法。）
用户是否知道您收集的数据类型及其存储位置（即服务器与本地与应用程序）？您是否允许选择加入/退出共享数据（过去、现在和未来）？
用户是否知道您采取了哪些措施来保护他们的数据？你用什么加密？
伦理
您收集的数据是否超过满足产品需求所需的最低数据？你储存它吗？
您是否对您的产品进行风险分析？是否包含侵犯用户隐私的风险？您是否根据风险分析将您的数据（应用程序、设备和服务器）分类为高、中或低风险？您是否使用风险管理的评估来选择合适的身份验证机制？
您是否有一个团队或个人的官方职责是为客户倡导道德、隐私和安全？
你有安全审计吗？隐私审计？具有安全和隐私目标的代码审计？您是否使用风险分析来确定审计的频率和范围？
您是否鼓励自己的开发人员进行渗透测试？在他们考虑如何破解您的产品时帮助/鼓励/支持他们？


嵌入式系统的 LINUX 安全强化清单
AdobeStock_356468597.jpg
安全没有灵丹妙药，更重要的是，对于哪些安全选项可用、它们做什么、它们有什么影响，甚至它们如何协同工作，没有单一的事实来源。

很多时候，假设您可以应用 STIG（或类似的配置指南）并神奇地生成一个安全系统。可用的 STIG 假定一个通用的解决方案，而不考虑单一用途嵌入式系统的细节。STIG 可以为开始一条安全路径（对于给定的威胁模型）提供基础，但它们并没有开始解决运营环境可能需要的安全配置或定制问题。

在这篇文章中，我们将列举许多可以部署在运行 Linux 的嵌入式系统中的安全机制，以保护该系统免受常见软件攻击。虽然传统的安全方法依赖于 CIA 的机密性、完整性和可用性三元组，但这篇文章的大部分内容主要集中在完整性的原则和执行上。

对于许多已部署的系统，他们使用的是内核稍旧的 Linux 发行版，这可能会限制使用一些较新的、与安全相关的特性，这些特性已被引入到更高的内核版本中。其中一些较新的内核特性（例如 LSM 堆栈）可能会使决策树复杂化，这种方式并不代表已部署的系统，因为它们引入了额外的配置和集成层。

威胁情景
当我们评估不同的安全配置时，我们通常会针对以下场景查看配置：

基于网络的保护（即，将攻击者拒之门外）

应用程序保护

多用户环境

执行枢轴

传统信息保障 (IA) 保护

使用这些威胁场景，我们可以推断出为什么需要深度防御的许多原因，同样我们可以看到 STIG 等配置指南的不足之处。举个例子，如果用户能够绕过网络/应用程序样式的防御并在系统上获得任意执行，那么他们将处于提升权限以执行其余攻击的情况. 当我们说应用程序只能访问这些时，我们主要关心的是这种情况

文件、套接字和 IPC，仅此而已。我们专注于防止破坏应用程序的攻击者旋转、提升权限并在系统上建立立足点。

基础
在我们进入各种内核和操作系统级别的安全配置选项之前，我们需要强调安全启动的重要性。至少，使用的任何安全引导选项都必须强制内核、内核命令行和 initramfs 的完整性。内核命令行和引导参数使攻击者能够改变系统行为，减轻或绕过各种安全相关功能，并在运行时更改各种配置选项。

使用哪种特定的安全引导解决方案取决于可用硬件、操作环境和系统的任何特定约束。

一般来说，安全启动选项包括： 

UEFI 安全启动

受信任的蛴螬

tboot 或 TrueBoot（使用 Intel 的 TXT 扩展）

受密码保护的 Grub

供应商特定的解决方案 

内核配置
这些更改将需要重新编译内核，尽管还有其他原因也需要编译内核，包括减少攻击面、删除未使用的驱动程序、性能调整等。许多流行的 Linux 发行版附带的内核旨在成为一刀切，应针对特定实例和用例量身定制。

这只是对各种与安全相关的内核选项的简要介绍，并不包括在内。根据目标系统、用例和环境，由于遗留软件、性能或其他操作限制，可能无法更改其中一些设置。此外，其中许多配置依赖于平台，为了简洁起见，我们仅探索 x86_64 配置。

内核配置选项
CHECKPOINT_RESTORE - 在各种崩溃/故障（可能导致任意代码执行）时启用特定代码和内存执行。[安全建议：CHECKPOINT_RESTORE=n]

BPF_JIT_ALWAYS_ON - 使 BPF 子系统能够动态（可执行）代码进入正在运行的内核（可能导致任意代码执行和破坏安全功能）[安全建议：BPF_JIT_ALWAYS_ON=n]

USERFAULTFD - 允许在用户空间处理页面错误，并可用于访问不应访问或可能导致信息泄漏的内存。[安全建议：USERFAULTF=n]

COMPAT_BRK - 禁用内核堆随机化，可能更容易利用内核中的各种内存溢出。[安全建议：USERFAULTFD=n]

SLAB_FREELIST_RANDOM - 启用或禁用内核堆的随机化，可能更容易利用内核堆溢出。[安全建议：SLAB_FREELIST_RANDOM=y]

SLAB_FREELIST_HARDENED - 保护内核slab的元数据，可能使执行各种slab / heap攻击变得更加困难。[安全建议：SLAB_FREELIST_HARDENED=y]

CONFIG_SHUFFLE_PAGE_ALLOCATOR - 增加页面分配地址的随机性。[安全建议：CONFIG_SHUFFLE_PAGE_ALLOCATOR=y] 

Kprobes / Oprofile / GCov - 启用跟踪内核和文件系统，可能导致信息泄露并促进某些逆向工程任务。在已部署的系统上，这些都应该被禁用并从内核中删除。

STACKPROTECTOR - 为内核内存启用 GCC 的堆栈保护器，使其更难利用各种内核堆栈漏洞。[安全建议：STACKPROTECTOR=y]

STACKPROTECTOR_STRONG - 启用堆栈金丝雀（在特定条件下），使其更难利用各种内核堆栈漏洞。[安全建议：STACKPROTECTOR_STRONG=y]

VMAP_STACK - 启用具有显式保护页面的虚拟堆栈映射，从而更难以执行各种内核堆栈漏洞。[安全建议：VMAP_STACK=y]

REFCOUNT_FULL - 强制在条件下对各种引用计数进行全面验证，从而潜在地防止可能导致释放漏洞后使用的情况。[安全建议：REFCOUNT_FULL=y]

MODULE_SIG - 启用可加载内核模块上的签名验证。请注意，启用此内核选项将对集成商/部署的系统施加各种其他限制，并且需要考虑保护签名密钥、将（公共）密钥注册到系统钥匙串中，并且可能不完全支持或易于使用与一些第 3 方驱动程序。模块驱动程序签名明确删除了攻击者可以用来在系统上枢转和/或获得更高权限访问的一种可能的攻击向量。此处的安全建议明确需要 2 个内核选项，以便启用和强制执行驱动程序签名。[安全建议：MODULE_SIG=y && MODULE_SIG_FORCE=y]

CONFIG_RETPOLINE - 禁用内核中推测执行路径的使用（即，防止对系统的各种侧通道攻击）。[安全建议：RETPOLINE=y]

CONFIG_X86_INTEL_MPX - 启用英特尔的内存保护扩展，它启用影子页面、堆栈保护，并可用于防止各种级别的应用程序级漏洞。注意：MPX 扩展需要相当新的 Intel 硬件/芯片组。[安全建议：X86_INTEL_MPX=y]

CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS - 在虚拟化或多执行上下文环境中启用内存标记，并使 IOMMU 能够提供特定于应用程序的内存边界实施和优化。[安全建议：X86_INTEL_MEMORY_PROTECTION_KEYS=y] 

Intel 的 TSX - 使用 Intel 扩展来优化锁定和各种操作，但是 TSX 扩展也被证明会在系统中引入各种边信道攻击。[安全建议：X86_INTEL_TSX_MODE_ON=n]

CONFIG_KEXEC - 无需重新初始化硬件即可加载新的内核或 ELF 映像。KEXEC 有可能绕过安全启动，并暴露内存中的秘密。[安全建议：KEXEC=n && KEXEC_FILE=n && KEXEC_JUMP=n]

CONFIG_RANDOMIZE_BASE - 强制内核的地址空间布局随机化，抑制对内核和数据结构的各种潜在攻击。[安全建议：RANDOMIZE_BASE=y && RANDOMIZE_MEMORY=y]

CONFIG_LIVEPATCH - 使内核能够在运行时动态修补，暴露多个潜在的攻击向量，并可能使攻击者禁用各种安全保护。[安全建议： LIVEPATCH=n] 

CONFIG_FUSE_FS - 允许创建虚拟的用户空间文件系统，可能会绕过安全功能和/或暴露各种安全漏洞。[安全建议：FUSE_FS=n]

Kernel Hacking - 内核黑客子系统启用了多种功能，为开发人员提供访问和洞察内核，可能绕过 ASLR 强制执行，启用调试等。[安全建议：应禁用此子菜单下的所有选项] 

CONFIG_SECURITY - 使内核能够为安全模块和配置提供多种设施，从而可能使攻击者绕过安全强制措施。注意：这还需要您配置显式安全模块，例如 SELinux。【安全建议：SECURITY=y；请注意，将此设置为 Y 将需要额外的配置，并且不包括在内。]

CONFIG_PAGE_TABLE_ISOLATION - 从用户空间取消映射内核地址空间并帮助防止各种硬件级别的侧面攻击。[安全建议：PAGE_TABLE_ISOLATION=y]

CONFIG_HARDENED_USERCOPY - 对从用户 -> 内核空间复制数据执行额外的验证（即，作为系统调用的一部分），从而更难进行各种错误和漏洞。[安全建议：HARDENED_USERCOPY=y]

FORTIFY_SOURCE - 强制编译器在构建内核时验证字符串副本；可以帮助防止内核中的各种传统缓冲区溢出错误。[安全建议： FORTIFY_SOURCE=y] 

STATIC_USERMODEHELPER - 强制内核使用单个用户模式助手，该助手调度正确的助手。用户模式助手用于处理二进制格式、挂载文件系统等，并且围绕用户模式助手实施限制使得破坏保护或执行各种特权升级攻击变得更加困难。[安全建议：STATIC_USERMODEHELPER=y]

CONFIG_LOCK_DOWN_KERNEL - 禁用可用于执行各种侧通道和权限提升攻击的各种内核接口。[安全建议：LOCK_DOWN_KERNEL=y && LOCK_DOWN_MANDATORY=y]

SECURITY_SELINUX - 启用 SELinux 强制访问控制框架和各种支持选项。正如我们之前在博客中所讨论的，SELinux 支持将基于 MAC 的策略应用于应用程序、数据和用户。此外，SELinux 支持标记网络流量（即，在虚拟化或 docker 环境中，您希望将特定流量限制到特定执行环境）。笔记：以下建议假定您有一个有效且功能齐全的系统策略，因为它们会阻止在运行的系统上开发该策略。这是一个很好的例子，说明需要爬行、步行、跑步的方法，所有的部分最终都需要结合在一起。[安全建议：SECURITY_SELINUX=y && SECURITY_SELINUX_BOOTPARAM=n && SECURITY_SELINUX_DISABLE=n && SECURITY_SELINUX_DEVELOP=n]

CONFIG_SECURITY_LOADPIN - 强制内核仅从根（或其他静态定义的文件系统）加载固件、kexec 映像（如果启用）、安全策略（即，对于 SELinux）、模块等。抑制各种攻击向量和文件系统挂载点的重新绑定。[安全建议：SECURITY_LOADPIN=y]

CONFIG_INTEGRITY - 启用完整性测量子系统，它为解决应用程序白名单提供了可能的解决方案。IMA 提供了 Titanium 白名单的替代方案，并强制对系统进行各种操作和性能限制，如果使用 Titanium，您可能希望禁用 IMA。[安全建议：INTEGRITY=y && IMA=y && IMA_APPRAISE=y && CONFIG_EVM=y] 

其他内核详细信息
当然，还有许多其他与安全相关的内核选项和配置细节高度依赖于特定用例、特定网络需求和目标应用程序。仅在内核配置的网络部分，就有数百个与安全相关的配置，只有在特定用例需要时才需要选择它们。例如，有一些选项可以启用网络流量的扩展属性和标记，这在具有多个容器的环境或需要将网络流量分离和隔离到特定执行域的虚拟化环境中最有用。同样，有许多与安全相关的选项（即标签、扩展属性等）。

许多指定的安全选项在内核配置期间需要额外的细节（即指定用户模式助手）。同样，许多指定的安全选项需要增量方法，并且很可能需要单独的开发和供应系统，以调整特定的应用程序和/或设置。我们没有在上面特别提到它，但一些选项专门强制执行操作限制，这可能与系统历史上的使用方式相冲突。虽然希望启用上述所有选项，但操作和/或性能限制可能会显着阻碍启用某些选项的能力。对于正在进行技术更新的遗留系统尤其如此，在这种情况下，应启用尽可能多的选项。 

连接点
坚持我们的威胁向量，想法是限制应用程序可以做什么，并防止攻击者能够转向更高的特权级别（即用户特权或用户->内核特权），或修改生成的系统，还有许多其他的 Linux 功能应该使用。利用这些功能和配置将有助于实施深度防御并补充上述内核选项。应该注意的是，下面确定的配置选项只是一个代表性的集合，不应被视为具有包容性，它们可能需要额外的缓解措施来防止新引入的威胁向量。 

结合足够多的部分，我们可以努力避免在已部署的系统上拥有高度特权的用户，并且很难在系统上进行调整和/或获得立足点。从本质上讲，纵深防御方法使我们能够推动“单一目的”Linux 环境。 

自主访问控制 (DAC)
Linux 和大多数其他 POSIX 操作环境提供粗略的 DAC，这些 DAC 通常由用户、组和世界权限组成。DAC 建立了可用于防止访问特定目录或应用程序的构建块，但它们也具有限制性。

在大多数 POSIX 环境中，您只能将 DAC 策略应用于单个组。使用传统的 DAC 实施，您通常无法实施约束，例如：

网络服务器只能访问这些特定文件（不能访问其他文件）。为了帮助克服传统 DAC 机制施加的限制，许多文件系统现在支持使用扩展属性。

扩展属性支持细粒度权限、多个组级分配，并为强制访问控制和 IMA 等白名单技术铺平道路。此外，扩展属性可以通过 IMA 和类似方法进行验证（因此您可以验证它们没有被更改）。然而，单独的扩展属性会带来另一个问题，并且通常假设管理员具有高权限（从而鼓励攻击者尝试提升权限并成为“超级用户”）。这种固有的弱点使我们沿着以下部分和集成的道路前进，这样我们就可以实现纵深防御。

强制访问控制 (MAC)
SELinux 等 MAC 引擎让我们更接近于能够强制执行约束，例如应用程序只能访问这些特定文件、套接字、IPC，而不能访问其他任何东西。然而，MAC 引擎也假定系统上有一个高特权用户（即“root”），从而使攻击者有一种机制来尝试获得 root 级别的访问权限。

对于 SELinux，应该使用有针对性的策略，并且应该标记系统上的所有对象。应针对特定应用程序或用例定制目标策略，例如为用户定义的应用程序提供适当的标签和策略。此外，如果内核配置正确，SELinux 策略就无法更改，并且这些不同形式的枢轴或尝试成为“超级用户”的效果将失败。

能力
Linux 功能提供了一种机制，使非特权进程（即，使用 DAC 或 MAC 受限的进程）能够执行某些特权操作。例如，此启用（或限制）使应用程序能够绑定到低端口，同时仍以普通用户身份运行。由于初始访问向量或受感染的应用程序在与系统其余部分交互的方式上可能受到限制，因此这可能会使对系统的旋转或完全控制变得更加困难。

功能可以由应用程序专门设置（即通过系统调用），这通常由setuid 应用程序使用或通过扩展属性的应用程序来设置。此外，可以通过使用 cgroup 和命名空间（docker 和其他容器引擎用于隔离其应用程序的相同构建块）来限制功能。在使用扩展属性来实施应用程序能力的情况下，还需要使用 IMA 或类似的能力来实施扩展属性和权限的完整性。

Linux功能手册页提供了可以为进程或应用程序设置和建立的所有功能的完整列表。

功能应该应用于不需要完全“超级用户”权限来执行其操作的所有应用程序和服务。

systemd 在其无限的荣耀中
大多数基于 Linux 的系统已经过渡到使用 systemd 进行服务和应用程序管理以及系统级配置。鉴于 Systemd 的复杂性以及可以配置和使用的多种方式，它也可能是一个完整的操作系统。最近，RedHat 等组织一直在扩展 systemd 的功能，甚至记录了一些更高级（但同样重要）的安全相关配置（https://www.redhat.com/sysadmin/mastering-systemd）。

沙盒 
Systemd 的沙盒集成了多个功能组件和/或特性，并致力于限制应用程序的使用方式。沙盒让我们更接近这个应用程序只能访问这些文件而不能访问其他任何东西的场景，并删除了上面确定的许多威胁向量。沙盒使用名称和 cgroup 来强制执行功能、扩展属性、MAC 和各种其他安全选项。沙盒应该用于由 systemd 管理的所有应用程序和服务。

CHROOT
systemd 提供了一个原生的 chroot 接口，它建立在沙盒之上，甚至进一步强制了*此应用程序只能访问这些文件而不能访问其他文件*的用例。在这种情况下，引入了一种新的结构，包括特定应用程序所需的库和配置文件在内的所有文件都被重新定位（物理地或通过使用硬链接）到新的根目录中，并且 `chroot` 系统调用是用于设置新的

root 为应用程序，使其只能访问其自己的 chroot 中的文件。这应该很明显，但是在 chroot 中，所有其他约束和组件（包括 DAC 和功能）都被强制执行。

在可行的情况下，chroots 应该用于所有系统级服务和面向公众的服务，例如 Web 服务器。

系统调用限制
Systemd 还提供了一种从应用程序服务中删除系统调用的机制。这与下面描述的 seccomp-bpf 方法非常相似，并且实际上在幕后使用相同的内核接口，因为它使用 seccomp 配置文件。有关使用 systemd 的 seccomp 过滤器的更多详细信息，请参见 systemd.exec 手册页。

白名单
根据底层实现，（应用程序）白名单提供了强大的防御，可以防止攻击者携带自己的工具（或应用程序）并能够实现持久性和/或任意代码执行。在无法引入新工具的情况下，攻击者被迫使用他们在系统上可用的东西。白名单是限制攻击者并帮助防御枢轴和特权升级的重要考虑因素。

暗示但未明确说明，强大的白名单解决方案应提供完整性机制，该机制经过加密验证和强制执行，并引入了自己的约束（使密钥远离攻击者权限、系统更新、支持的文件系统等）。

限制系统调用
类似于 Linux 支持从应用程序中删除特定功能的方式，它也支持从应用程序中删除特定系统调用。  

seccomp -bpf框架使用 BPF（如果你很聪明，你会注意到我们在上面部分禁用了它；我们专门禁用了即时 BPF 接口，该接口用于动态跟踪，可用于实现解释LSM，同时离开核心

BPF 已启用，因此我们可以使用它来过滤系统调用）以限制应用程序可以使用的系统调用。在 x86_64 上，Linux 目前定义了 313 个系统调用，几乎可以肯定单个应用程序只使用了几十个。使用seccomp-bpf可以从应用程序中删除剩余的系统调用，从而减少攻击面并极大地抑制攻击者获取访问权限、转换和提升权限的方式。当您开始为应用程序使用 BPF 过滤器时，您还需要一种机制来为特定应用程序强制执行 BPF 过滤器的完整性。

systemd、docker、qemu 和 Chrome 常用通过seccomp-bpf进行的受限系统调用。此外，它们应该应用于系统上的所有应用程序。

包起来
显而易见，安全方面没有灵丹妙药。您不能简单地切换开关，并神奇地拥有一个安全系统。同样，没有一种适合所有解决方案的解决方案，并且每个解决方案或切换必须针对正在开发的每个系统和应用程序进行仔细评估。安全需要牢牢地扎根于系统开发活动中，并针对特定的威胁向量进行评估。它还必须考虑给定场景在环境中的可能性。 

纵深防御是 Linux 安全的基础。正如我们在上面所探讨的，通常启用特定的安全选项需要额外的配置。此附加配置可能需要选择附加选项，或指定静态配置元素。一些安全选项滚雪球，并且还需要选择其他安全选项以减轻第一个安全选项引入的新威胁。例如，我们强制 SELinux 配置并阻止系统策略开发，以及在运行时禁用 SELinux。显然，这里有一个必须遵循的操作顺序，并且安全选项的集合强制执行特定的操作最佳实践。 

为了进一步阅读，上面的选项是我们“安全嵌入式系统的 10 条原则”的组成部分。阅读博文并立即下载白皮书 >>