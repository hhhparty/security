# 第5讲 认证类测试 Authentication Testing

在计算机安全中，身份验证是试图验证通信发送者的数字身份的过程。此类进程的一个常见示例是登录进程。测试身份验证模式意味着理解身份验证过程是如何工作的，并使用该信息来规避身份验证机制。


本章节包括以下测试子类：

- 经过加密信道传输的凭证测试  Testing for Credentials Transported over an Encrypted Channel
- 默认凭据测试 Testing for Default Credentials
- 弱锁定机制测试 Testing for Weak Lock Out Mechanism
- 身份验证模式绕过测试  Testing for Bypassing Authentication Schema
- 有漏洞的记忆密码测试  Testing for Vulnerable Remember Password
- 浏览器缓存脆弱性测试  Testing for Browser Cache Weaknesses
- 弱密码策略测试  Testing for Weak Password Policy
- 弱安全回答问题测试  Testing for Weak Security Question Answer
- 弱密码更改或重置功能测试 Testing for Weak Password Change or Reset Functionalities
- 替代通道若身份验证测试 Testing for Weaker Authentication in Alternative Channel

## 经过加密信道传输的凭证测试  Testing for Credentials Transported over an Encrypted Channel

ID : WSTG-ATHN-01

### 概述

测试凭据传输意味着验证用户的身份验证数据是否通过加密通道传输，以避免被恶意用户截获。分析的重点是尝试了解数据是否未加密地从 Web 浏览器传输到服务器，或者 Web 应用程序是否使用 HTTPS 等协议采取适当的安全措施。HTTPS 协议构建在 TLS/SSL 上，用于加密传输的数据，并确保用户被发送到所需的站点。

显然，流量被加密并不一定意味着它完全安全。安全性还取决于所使用的加密算法和应用程序正在使用的密钥的鲁棒性，但本节中不会讨论此特定主题。

有关测试 TLS/SSL 通道安全性的更详细的讨论，请参阅弱 SSL/TLS 测试一章。在这里，测试人员将尝试了解用户为登录到网站而输入 Web 表单中的数据，是否使用安全协议进行传输，从而免受攻击者攻击。

现在，此问题的最常见示例是 Web 应用程序的登录页。测试人员应验证用户的凭据是否通过加密通道传输。为了登录到网站，用户通常必须填写一个简单的表单，使用 POST 方法将插入的数据传输到 Web 应用程序。不太明显的是，这些数据可以使用 HTTP 协议传递，HTTP 协议以不安全的、明文形式传输数据，或者使用 HTTPS 协议（在传输过程中加密数据）。使事情更加复杂的是，站点有可能通过 HTTP 访问登录页，但随后它实际上通过 HTTPS 发送数据。此测试是为了确保攻击者无法通过使用嗅探器工具嗅探网络来检索敏感信息。

### Test Objectives

验证用户的身份验证数据是否通过加密通道传输；验证用户使用了何种（例如https等）加密传输方式。

### How to Test

#### 黑盒测试

下面的例子中使用web代理捕获数据包头部并检查它们，以此发现问题。

##### 例1 通过 HTTP 使用POST方法发送数据

假设登录页显示一个包含字段"用户"、"通过"和"提交"按钮的窗体，用于验证并授予对应用程序的访问权限。如果我们使用 Web 代理查看请求，我们可以得到类似内容：
```
POST http://www.example.com/AuthenticationServlet HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404
Accept: text/xml,application/xml,application/xhtml+xml
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://www.example.com/index.jsp
Cookie: JSESSIONID=LVrRRQQXgwyWpW7QMnS49vtW1yBdqn98CGlkP4jTvVCGdyPkmn3S!
Content-Type: application/x-www-form-urlencoded
Content-length: 64

delegated_service=218&User=test&Pass=test&Submit=SUBMIT
```
测试人员可以理解 POST 请求使用 HTTP 将数据发送到页面。因此，数据传输没有加密，恶意用户使用类似Wireshark的工具，就可以拦截用户名和密码。

##### 例2 通过HTTPS发送POST数据

假设我们的web应用使用HTTPS协议加密我们发送的数据，或者至少在传输敏感数据时采用加密方式。在这个例子中，我们接收到的POST请求如下所示：
```
POST https://www.example.com:443/cgi-bin/login.cgi HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it;
rv:1.8.1.14) Gecko/20080404
Accept: text/xml,application/xml,application/xhtml+xml,text/html
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: https://www.example.com/cgi-bin/login.cgi
Cookie: language=English;
Content-Type: application/x-www-form-urlencoded
Content-length: 50
Command=Login&User=test&Pass=test

```

可以看到请求地址为 ```www.example.com:443/cgi-bin/login.cgi```，使用了HTTPS协议。这确保了我们的登录凭据使用加密信道传输。

##### 例子3 通过HTTPS传输凭据（post数据），使用http协议传输页面

想象一下，可以通过 HTTP 访问网页，并且只有从身份验证表单发送的数据通过 HTTPS 传输。例如，当我们位于一家大公司的门户网站上时，会出现这种情况，该公司提供各种公开的信息和服务，无需识别身份，但当用户登录时，该网站也有可从主页访问的专用部分。因此，当我们尝试登录时，请求的标头将类似于以下示例：
```
POST https://www.example.com:443/login.do HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404
Accept: text/xml,application/xml,application/xhtml+xml,text/html
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://www.example.com/homepage.do
Cookie: SERVTIMSESSIONID=s2JyLkvDJ9ZhX3yr5BJ3DFLkdphH0QNSJ3VQB6pLhjkW6F
Content-Type: application/x-www-form-urlencoded
Content-length: 45

User=test&Pass=test&portal=ExamplePortal
```

查看一下Referer字段，内容指示了当前请求来自于何站点，我们可以看到是http开头的，这说明访问页面时使用了http协议。而当前POST方法是使用HTTPS协议。

##### 例子 4: Sending data with GET method through HTTPS 
在最后一个示例中，假设应用程序使用 GET 方法传输数据。此方法绝不应该传输敏感数据（如用户名和密码），因为数据以明文形式显示在 URL 中，从而导致一系列的安全问题。例如，请求的 URL 可从服务器日志或浏览器历史记录中轻松获取，这使得您的敏感数据可供未经授权的人员检索。因此，此示例纯粹是演示性的。

实际上强烈建议改用 POST 方法。
```
GET https://www.example.com/success.html?user=test&-pass=test HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it;
rv:1.8.1.14) Gecko/20080404
Accept: text/xml,application/xml,application/xhtml+xml,-
text/html
Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: https://www.example.com/form.html
If-Modified-Since: Mon, 30 Jun 2008 07:55:11 GMT
If-None-Match: “43a01-5b-4868915f”
```

您可以看到数据以 URL 中的明文传输，而不是像以前那样在请求正文中传输。但是，我们必须考虑 SSL/TLS 是 5 级协议，其级别低于 HTTP，因此整个 HTTP 数据包仍被加密，因此使用嗅探器无法读取恶意用户的 URL。然而，如前所述，使用 GET 方法向 Web 应用程序发送敏感数据不是一个好的做法，因为 URL 中包含的信息可以存储在代理和 Web 服务器日志等许多位置。

#### 灰盒测试

与 Web 应用程序的开发人员交谈，并尝试了解他们是否知道 HTTP 和 HTTPS 协议之间的差异，以及为什么他们应该使用 HTTPS 传输敏感信息。然后，请与它们检查是否在每个敏感请求（如登录页中的请求）中使用 HTTPS，以防止未经授权的用户拦截数据。

### Tools
- OWASP Zed Attack Proxy (ZAP)
- mitmproxy
- Burp Suite
- Wireshark
- TCPDUMP

### References
- HTTP/1.1: Security Considerations
- SSL is not about encryption

## 默认凭据测试 Testing for Default Credentials

ID : WSTG-ATHN-02

### 概述

很多web应用使用了开源的、商业的公开软件，它们的安装、使用仅需要简单步骤就可完成，此外还有一些硬件设备（路由、数据存储）等也使用了基于Web的配置或管理接口。

通常，这些应用程序安装后采用默认配置或未配置状态，系统运行时可能仍可使用初始身份认证凭据。而这些默认凭据是渗透测试人员以及恶意攻击者所熟知。

此外，在许多情况下，在应用程序上创建新帐户时，会生成默认密码（具有某些标准特征）。如果此密码是可预测的，并且用户在第一次访问时未更改密码，则可能导致攻击者未经授权访问应用程序。

形成这些安全问题的原因在于：
- 缺乏经验的 IT 人员，他们没有意识到更改基础结构组件默认密码的重要性，或者将密码保留为默认密码，以便"易于维护"。
- 程序员离下了后门，很容易访问和测试他们的应用程序，后来忘记删除他们。
- 具有内置不可移动默认帐户且具有预设用户名和密码的应用程序。
- 不强制用户在第一次登录后更改默认凭据的应用程序。

### How to Test

#### 普通应用的默认凭据测试

现实中，应用总会暴漏一些信息，显示出这个应用所使用的基础组件或插件。例如：Cisco路由器的默认密码。安全测试人员要收集整理这些默认凭据，测试哪些可用。

当没有默认和常见用户帐户列表的应用程序时，我们可以尝试猜测有效的默认凭据。请注意，正在测试的应用程序可能启用了帐户锁定策略，并且使用已知用户名进行多次密码猜测尝试可能会导致帐户被锁定。如果可以锁定管理员帐户，则系统管理员重置帐户可能麻烦。

许多应用程序都有详细的错误消息，告知网站用户输入的用户名的有效性。在测试默认或可猜测的用户帐户时，此信息将非常有用。例如，可以在登录页、密码重置和忘记密码页以及注册页上找到此类功能。找到默认用户名后，您也可以开始猜测此帐户的密码。

由于这些类型的默认凭据通常绑定到管理帐户，因此您可以以这种方式继续：
- 尝试下列常见的管理员用户名：```admin```,```administrator```,```root```,```system```,```guest```,```operator```,```super```,```sys```,```manager```...
  - 还有一些如：```test```,```test1```,```guest```
  - 在用户名字段和密码字段尝试上述字符串的所有排列，以及中文字符串。
  - 如果应用存在用户名枚举脆弱性，那么你可以使用已经获知的用户名，或相似用户名进行猜测。
  - 密码域可以使用：```password```,```pass```,```123```,```123456```,```12345678```等的排列。
- 应用管理员用户的名称经常以应用名称、组织机构名称命名。可以使用这些字符串组合进行测试。
- 将信息收集到的联系人姓名列入破解字典。例如发现了 jdoe@example.com，那么可以使用搜索引擎或在程序中搜索这个名字。
- 尝试使用空白密码
- 查看页面源代码、Javascript脚本，查找可用的用户名和密码信息，例如：```If username='admin' then starturl=/admin.asp else /index.asp```，则说明admin是合法用户名称。
- 查看可能包含有趣注释和代码的源代码（或源代码备份）的备份目录。

#### 测试新账户的默认密码

当在应用程序中创建新帐户时，系统为该帐户分配默认密码。此密码可能具有一些标准特征，使其可预测。如果用户未在第一次使用时更改它（常会发生这种情况），或者用户尚未登录到应用程序，则可能导致攻击者未经授权访问应用程序。

在测试默认密码时，这里也适用之前给出的关于可能的锁定策略和详细错误消息的建议。

可以应用以下步骤来测试这些类型的默认凭据：
- 查看“用户注册”页，确定应用程序用户名和密码的预期格式以及最小或最大长度。如果用户注册页不存在，确定组织是否对用户有标准命名约定（例如，电子邮件中有个@）。
- 尝试从应用程序推断如何生成用户名。例如：是否可以自选用户名，或是系统根据某些个人信息（姓名）生成账户名称。如果发现某种命名模式，那么要枚举所有可能的用户名，并尝试登录获得响应，再根据响应进行测试。
- 尝试确定系统生成的密码是否可以预测。
- 尝试空白密码

#### 灰盒测试

以下步骤属于完全的灰盒测试方法，如果只有部分信息可用，那么参考上面的黑盒测试部分加以补充。
- 与 IT 人员交谈，以确定他们用于管理访问的密码以及如何执行应用程序的管理。
- 询问 IT 人员是否更改了默认密码以及是否禁用了默认用户帐户。
- 检查用户数据库的默认凭据，如黑盒测试部分所述。还要检查空密码字段。
- 检查代码的硬编码用户名和密码。
- 检查包含用户名和密码的配置文件。
- 检查密码策略，如果应用程序为新用户生成自己的密码，请检查在此过程中正在使用的策略。

### Tools

- Burpsuite intruder
- THC Hydra
- Nikto 2


## 弱锁定机制测试 Testing for Weak Lock Out Mechanism

ID: WSTG-ATHN-03

### 概述

账户锁定机制用于缓解暴力攻击。帐户通常在 3 到 5 次不成功的登录尝试后锁定，并且只能在预定的时间、自助解锁机制或管理员的干预后解锁。帐户锁定机制要求在保护帐户免受未经授权的访问和保护用户不被拒绝授权访问之间取得平衡。

请注意，此测试应涵盖适当的锁定机制的身份验证的所有方面，例如，当用户在忘记密码机制期间收到安全问题时（请参阅"弱安全问题测试/答案"）。

### Test Objectives

- 评估账户锁定机制缓解暴力猜测密码的能力；
- 评估解锁机制对未经授权的账户的解锁阻力。

### How to Test
通常，要测试锁定机制的强度，要确定一个允许执行此项测试的账户，并在完成测试后对该账户的锁定状态进行解除。

要评估账户锁定机制缓解暴力破解的能力，请多次使用不正确的密码进行登录，然后再使用正确的密码来验证账户是否被锁定。测试可能如下例所示进行：
- 尝试使用错误密码登录 3 次。
- 使用正确的密码成功登录，从而显示锁定机制在 3 次不正确的身份验证尝试后不会触发。
- 尝试使用错误密码登录 4 次。
- 使用正确的密码成功登录，从而显示锁定机制在 4 次不正确的身份验证尝试后不会触发。
- 尝试使用错误密码登录 5 次。
- 尝试使用正确的密码登录。应用程序返回"您的帐户被锁定"，从而确认该帐户在 5 次不正确的身份验证尝试后被锁定。
- 尝试在 5 分钟后使用正确的密码登录。应用程序返回"您的帐户已锁定"，从而显示锁定机制在 5 分钟后不会自动解锁。
- 尝试在 10 分钟后使用正确的密码登录。应用程序返回"您的帐户已锁定"，从而显示锁定机制在 10 分钟后不会自动解锁。
- 15 分钟后使用正确的密码成功登录，从而显示锁定机制在 10 到 15 分钟后自动解锁。

具有校验码（CAPTCHA)可能会阻碍暴力攻击，但它们可能带有自己的一组弱点，不应取代锁定机制。

要评估解锁机制对未授权访问的阻力，需要启动解锁机制并查看弱点。典型的解锁机制可能涉及机密问题或通过电子邮件发送的解锁链接。解锁链接应该是一个唯一的一次性链接，以阻止重放和猜测。机密问题和答案应该很强。

注意，解锁机制仅应用于解锁账户。它域密码恢复机制不同。

实施账户锁定机制时需要考虑的因素有：
- 对应用程序进行暴力密码猜测的风险是什么？
- CAPTCHA 是否足以降低此风险？
- 是否正在使用客户端锁定机制（例如 Javascript）？
  - 如果是这样，请禁用客户端代码进行测试。
- 计数需要多少次不成功登录会触发锁定机制。
  - 如果锁定阈值较低，则有效用户可能锁定得过于频繁。
  - 如果锁定阈值较高，则攻击者在帐户被锁定之前可以进行暴力强制的尝试就越多。
  - 根据应用程序的目的，5 到 10 次不成功的尝试范围是典型的锁定阈值。
- 如何解锁帐户？
  - 管理员手动操作：这是最安全的锁定方法，但可能会给用户带来不便，并占用管理员的"宝贵"时间。
    - 请注意，应该设置一种管理员手动恢复的机制，以防不时之需。
    - 如果攻击者的目标是锁定 Web 应用程序的所有用户的帐户，则此解锁机制可能会导致拒绝服务攻击。
  - 锁定时间：锁定持续时间是多少？这是否足以保护应用程序？例如，5 到 30 分钟的锁定持续时间可能是缓解暴力攻击和不便有效用户之间的良好折衷。
  - 自助服务机制：如前所述，此自助服务机制必须足够安全，以避免攻击者可以自行解锁帐户。

### Tools

手动

### References

See the OWASP article on Brute Force Attacks.

### 修复
根据风险级别应用帐户解锁机制。从最低到最高保证的顺序：

- 基于时间的锁定和解锁。
- 自助服务解锁（将解锁电子邮件发送到已注册的电子邮件地址）。
- 手动管理员解锁。
- 手动管理员解锁与积极的用户识别。

## 身份验证模式绕过测试  Testing for Bypassing Authentication Schema

ID : WSTG-ATHN-04

### 概述

身份验证是尝试验证通信发送方的数字标识的过程。此类进程的一个常见示例是登录过程。测试身份验证架构意味着了解身份验证过程的工作原理，并使用该信息绕过身份验证机制。

虽然大多数应用程序都需要身份验证才能访问私有信息或执行任务，但并非所有身份验证方法都能提供足够的安全性。对安全威胁的疏忽、无知或简单轻描淡写通常会导致身份验证方案，只需跳过登录页并直接调用应在执行身份验证后才能访问的内部页面，就可以绕过这些身份验证方案。

此外，通常可以通过篡改请求和诱使应用程序认为用户已经过身份验证来绕过身份验证措施。这可以通过修改给定的 URL 参数、通过操作窗体或伪造会话来实现。

与身份验证架构相关的问题可以在软件开发生命周期 （SDLC） 的不同阶段找到，例如设计、开发和部署阶段：

- 在设计阶段，错误可能包括要保护的应用程序部分的错误定义、选择不应用强加密协议来保护凭据传输，以及更多。
- 在开发阶段，错误可能包括输入验证功能实现不正确或未遵循特定语言的安全最佳实践。
- 在应用程序部署阶段，由于缺乏所需的技术技能或缺少良好的文档，应用程序设置（安装和配置活动）期间可能会出现问题。
### 如何测试

#### 黑盒测试

对于web应用，有几种绕过认证模式的方法：
- 直接访问页面（暴力浏览）
- 修改请求参数
- 会话ID预测/猜测
- SQL注入

##### 直接访问页面（暴力浏览）

如果 Web 应用程序仅在登录页上实现访问控制，则可以绕过身份验证架构。例如，如果用户通过强制浏览直接请求其他页面，则该页在授予访问权限之前可能不会检查用户的凭据。尝试通过浏览器中的地址栏直接访问受保护的页面，以便使用此方法进行测试。

##### 参数修改
与身份验证设计相关的另一个问题是，当应用程序根据固定值参数验证成功登录时。用户可以修改这些参数，以在未提供有效凭据的情况下访问受保护区域。在下面的示例中，"经过身份验证"参数更改为"是"值，这允许用户获得访问权限。在此示例中，参数位于 URL 中，但代理也可用于修改参数，尤其是在在 POST 请求中作为表单元素发送参数或参数存储在 Cookie 中时。
```
http://www.site.com/page.asp?authenticated=no

raven@blackbox /home $nc www.site.com 80
GET /page.asp?authenticated=yes HTTP/1.0

HTTP/1.1 200 OK
Date: Sat, 11 Nov 2006 10:22:44 GMT
Server: Apache
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML><HEAD>
</HEAD><BODY>
<H1>You Are Authenticated</H1>
</BODY></HTML>
```

##### 会话 ID 预测
许多 Web 应用程序使用会话标识符（会话标识）管理身份验证。因此，如果会话 ID 生成是可预测的，则恶意用户可能能够找到有效的会话 ID 并获得对应用程序的未经授权的访问，从而模拟以前经过身份验证的用户。

在下图中，Cookie 中的值呈线性增长，因此攻击者可以轻松猜测有效的会话 ID。

<img src="images/04/Basm-sessid.jpg" width="480">


在下图中，Cookie 内部的值仅部分更改，因此可以将暴力攻击限制为下面显示的已定义字段。
<img src="images/04/Basm-sessid2.jpg" width="480">
##### SQL 注入（HTML 表单身份验证）
SQL 注入是一种广为人知的攻击技术。本节不会详细介绍此技术，因为本指南中有几个部分解释了超出本节范围的注入技术。


<img src="images/04/Basm-sqlinj.jpg" width="480">

下图显示，使用简单的 SQL 注入攻击，有时可以绕过身份验证窗体。

<img src="images/04/Basm-sqlinj2.jpg" width="480">

#### 灰盒测试
如果攻击者能够利用以前发现的漏洞（例如目录遍历）或从 Web 存储库（开源应用程序）检索应用程序源代码，则有可能对身份验证过程的实现执行精细的攻击。

在下面的示例 （PHPBB 2.0.13 - 身份验证旁路漏洞）中，在第 5 行，```unserialize() ``` 函数解析用户提供的 Cookie 并在```$row``` 数组中设置值。在第 10 行，将存储在后端数据库中的用户的 MD5 密码哈希与提供的密码哈希进行比较。
```PHP
if ( isset($HTTP_COOKIE_VARS[$cookiename . '_sid']) ||
{
     $sessiondata = isset( $HTTP_COOKIE_VARS[$cookiename . '_data'] ) ?
 
   unserialize(stripslashes($HTTP_COOKIE_VARS[$cookiename . '_data'])) : array();
 
   $sessionmethod = SESSION_METHOD_COOKIE;
   }
 
  if( md5($password) == $row['user_password'] && $row['user_active'] )
 
  {
  $autologin = ( isset($HTTP_POST_VARS['autologin']) ) ? TRUE : 0;
 }
```

In PHP, a comparison between a string value and a boolean value (1 - “TRUE”) is always “TRUE”, so by supplying the following string (the important part is “b:1”) to the unserialize() function, it is possible to bypass the authentication control:

```a:2:{s:11:“autologinid”;b:1;s:6:“userid”;s:1:“2”;}```

### Tools

- webgoat
- owasp-zap

### References
- Mark Roxberry: “PHPBB 2.0.13 vulnerability”
- David Endler: “Session ID Brute Force Exploitation and Prediction”

## 有漏洞的记忆密码测试  Testing for Vulnerable Remember Password

ID:WSTG-ATHN-05

### 概述

凭据是使用最广泛的身份验证技术。为了帮助用户获得凭据，出现了多种技术：
- 应用程序提供了一个记住我的功能，允许用户长时间保持身份验证，而无需再次询问用户的凭据。
- 密码管理器（包括浏览器密码管理器）允许用户以安全的方式存储其凭据，并在以后以用户形式注入凭据，而无需任何用户干预。

### Test Objectives
验证是否存在易受攻击的“记住我”或“密码管理”。

### How to Test
上面的方法提供了良好的用户体验，允许用户保持身份登录状态，但它们增加了攻击表面积。具体表现为：
- 以编码方式在浏览器的存储机制中存储凭据。这一情况，可以根据 Web存储测试方案（WSTG-CLNT-12）和检查 会话分析方案（WSTG-SESS-01）进行验证。凭据不应以任何方式存储在客户端程序中，并且应该由从服务器端生成的令牌进行代替。
- 自动注入用户凭据。这些凭据可能会被以下用户滥用：
  - ClickJacking 攻击
  - CSRF 攻击
- 对于令牌，应该对令牌生存期进行分析，某些令牌永远不会过期，如果这些令牌被盗，则使用户处于危险之中。请务必遵循会话超时测试方案（WSTG-SESS-07）。
### 修复

- 遵循[会话管理](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)良好做法。
- 确保没有凭据以明文形式存储，或在浏览器存储机制中以编码或加密的形式轻松检索;它们应存储在服务器端，并遵循密码存储良好做法。

## 浏览器缓存脆弱性测试  Testing for Browser Cache Weaknesses

ID :WSTG-ATHN-06

### 概述
在此阶段，测试人员检查应用程序是否正确指示浏览器不保留敏感数据。

浏览器可以存储用于缓存和历史记录的信息。缓存用于提高性能，因此无需再次下载以前显示的信息。历史机制用于方便用户，因此用户可以准确查看在检索资源时看到的内容。如果向用户显示敏感信息（如其地址、信用卡详细信息、社会保险号或用户名），则此信息可以存储用于缓存或历史记录，因此可以通过检查浏览器的缓存或只需按浏览器的"后退"按钮进行检索。
### Test Objectives
- 评估应用程序是否将敏感信息存储在客户端可访问的位置；
- 评估是否在身份验证和授权的会话之外仍能访问敏感信息。

具体来说，这将测试是否存储敏感信息：
- 在磁盘上或内存中，可能在使用之后仍能被获取；
- 使用浏览器"后退"按钮可能会返回到以前显示的屏幕。


### How to Test

#### 浏览器历史记录

从技术上讲，"后退"按钮是历史记录，而不是缓存（请参阅https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.13）。缓存和历史记录是两个不同的实体。但是，它们在显示以前显示的敏感信息时也有相同的弱点。

第一个最简单的测试包括将敏感信息输入到应用程序中并注销。然后，测试人员单击浏览器的"后退"按钮，检查在未经过身份验证时是否可以访问以前显示的敏感信息。

如果通过按下"后退"按钮，测试人员可以访问以前的页面，但不能访问新页面，则这不是身份验证问题，而是浏览器历史记录问题。如果这些页面包含敏感数据，则意味着应用程序不禁止浏览器存储它。

身份验证不一定需要参与测试。例如，当用户输入其电子邮件地址以注册新闻稿时，如果处理不当，此信息是可以检索的。

可以停止"后退"按钮显示敏感数据。这可以通过：
- 通过 HTTPS 提供页面。
- 设置Cache-Control: must-revalidate

#### 浏览器缓存
在这里，测试人员检查应用程序是否未将任何敏感数据泄漏到浏览器缓存中。为此，他们可以使用代理（如 OWASP ZAP）并搜索属于会话的服务器响应，检查服务器指示浏览器不要缓存任何数据的每个页面。此类指令可以在 HTTP 响应标头中发出，并带有以下指令：
- ```Cache-Control: no-cache, no-store```
- ```Expires: 0```
- ```Pragma: no-cache```


这些指令通常很健壮，尽管为了更好地防止文件系统上持续链接的文件，标头可能需要其他标志。其中包括：Cache-Control
- ```Cache-Control: must-revalidate, max-age=0, s-maxage=0```

HTTP/1.1:
```
Cache-Control: no-cache
```
HTTP/1.0:
```
Pragma: no-cache
Expires: <past date or illegal value (e.g., 0)>
```

例如，如果测试人员正在测试电子商务应用程序，他们应该查找包含信用卡号或其他财务信息的所有页面，并检查所有这些页面是否强制执行该指令。如果他们找到包含重要信息但未能指示浏览器不要缓存其内容的页面，他们知道敏感信息将存储在磁盘上，并且他们只需在浏览器缓存中查找页面即可仔细检查。

存储该信息的确切位置取决于客户端操作系统和已使用的浏览器。下面是一些示例：

- Mozilla Firefox:
  - Unix/Linux: ~/.cache/mozilla/firefox/
  - Windows: C:\Users\<user_name>\AppData\Local\Mozilla\Firefox\Profiles\<profile-id>\Cache2\
- Internet Explorer:
  - C:\Users\<user_name>\AppData\Local\Microsoft\Windows\INetCache\
- Chrome:
  - Windows:C:\Users\<user_name>\AppData\Local\Google\Chrome\User Data\Default\Cache
  - Unix/Linux: ~/.cache/google-chrome

#### 查看缓存的信息
Firefox 提供了用于查看缓存信息的功能，这可能对您作为测试人员有利。当然，业界也制作了各种扩展，以及您可能更喜欢或需要 Chrome、IE 浏览器或 Edge 的外部应用。

缓存详细信息也可通过大多数现代浏览器（如Firefox、Chrome和Edge）的开发人员工具获得。使用 Firefox 也可以使用 URL 检查缓存详细信息。about:cache
#### 检查移动浏览器的处理

对于移动浏览器，缓存指令的处理可能完全不同。因此，测试人员应使用干净的缓存启动新的浏览会话，并利用 Chrome的设备模式或 Firefox 的响应式设计模式等功能重新测试或单独测试上述概念。

此外，个人代理（如 ZAP 和 Burp Suite）允许测试人员指定哪些代理应该由蜘蛛/爬行者发送。这可以设置为匹配移动浏览器字符串，并用于查看被测试的应用程序发送的缓存指令。User-AgentUser-Agent

#### 灰盒测试
测试方法等效于黑盒情况，因为在这两种情况下，测试人员都完全有权访问服务器响应标头和 HTML 代码。但是，使用灰盒测试时，测试人员可能有权访问帐户凭据，以允许他们测试只有经过身份验证的用户才能访问的敏感页面。
### Tools
OWASP ZED PROXY

### 参考
在HTTP中的缓存：https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html

## 弱密码策略测试  Testing for Weak Password Policy
ID :WSTG-ATHN-07
### 概述
最普遍和最容易管理的身份认证机制是静态密码。密码表示王国的密钥，但经常被用户以可用性的名义颠覆。最常见的弱密码包括：123456，password，qwerty。

### Test Objectives

通过评估密码的长度、复杂性、重用和老化要求，确定应用程序对使用可用密码字典进行暴力强制密码猜测的阻力。

### How to Test

- 允许和禁止在密码中使用哪些字符？用户是否需要使用不同字符集（如小写字母和大写字母、数字和特殊符号）中的字符？
- 用户多久更改一次密码？用户在上次更改后更改密码的速度如何？用户可以通过连续更改 5 次密码来绕过密码历史记录要求，以便在上次密码更改后再次配置其初始密码。
- 用户何时必须更改其密码？
  - NIST和NCSC都建议不要强制常规密码过期，尽管根据 PCI DSS 等标准可能需要这样。
- 用户多久重复使用一次密码？应用程序是否维护用户以前使用的 8 个密码的历史记录？
- 下一个密码与最后一个密码的区分程度如何？
- 是否阻止用户使用密码中的用户名或其他帐户信息（如名字或姓氏）？
- 可以设置的最小和最大密码长度是多少，它们是否适合帐户和应用程序的敏感度？
- 是否可以设置常见密码，如 Password1，123456..

### References
https://owasp.org/www-community/attacks/Brute_force_attack

### Remediation
为了降低容易猜到的密码以方便未经授权的访问的风险，有两种解决方案：引入其他身份验证控制（即双重身份验证）或引入强密码策略。其中最简单、最便宜的是引入强密码策略，以确保密码长度、复杂性、重用和老化;虽然理想情况下，这两个应该实现。

## 弱安全回答问题测试  Testing for Weak Security Question Answer
ID :WSTG-ATHN-08
### 概述
安全问题和答案通常被称为"机密"问题和答案，通常用于恢复被遗忘的密码。它们通常在创建帐户时生成，并要求用户从一些预先生成的问题中选择并提供适当的答案。它们可能允许用户生成自己的问答对。这两种方法都容易出现不安全。

理想情况下，安全问题应生成只有用户知道，而其他人无法猜到或发现的答案。这比听起来要难。安全问题和答案取决于答案的保密性。应选择问题和答案，以便只有账户持有人知道答案。但是，尽管许多答案可能并不为人所知，但网站实施的大多数问题都会促进伪私有的答案。

#### 预生成的问题
大多数预先生成的问题在性质上相当简单，可能导致答案不安全。例如：
- 用户的家人或密友可能知道答案，例如"你母亲的婚前姓是什么？" "你的出生日期是什么？
- 答案可能很容易猜到，例如"你最喜欢的颜色是什么？" "你最喜欢的棒球队是什么？
- 答案可能是可被暴力猜测的，例如"你最喜欢的高中老师的名字是什么？答案可能很容易从公开的信息中下载得到，例如学校官方网站。
- 答案可能是可公开发现的，例如"你最喜欢的电影是什么？" - 答案可以很容易地在用户的社交媒体个人资料页面上找到。
#### 自生成问题
让用户生成自己的问题的问题是，它允许用户生成非常不安全的问题，甚至绕过安全问题的全部问题。下面是一些真实世界的例子，说明了这一点：
- "什么是 1+1？"
- "你的用户名是什么？"
- "我的密码是S3cur_ty！

### Test Objectives
检查有哪些不安全的在账户恢复过程中使用的“安全问题”。

### How to Test
#### 测试弱预生成问题

- 尝试通过创建新帐户或遵循"我不记得密码"过程来获取安全问题列表
- 尝试生成尽可能多的问题，以便清楚地了解所询问的安全问题的类型。
- 如果任何安全问题属于概述中的类别，则它们很容易受到攻击（猜测、暴力强迫、在社交媒体上提供等）。

#### 弱自生成问题的测试
尝试通过创建新帐户或配置现有帐户的密码恢复属性来创建安全问题。如果系统允许用户生成自己的安全问题，则很容易产生不安全的问题。如果系统在忘记密码功能期间使用自生成的安全问题，并且可以枚举用户名（请参阅帐户枚举和可猜测用户帐户测试，则测试人员应该很容易枚举一些自生成的问题。应该使用此方法找到几个弱的自我生成问题。

#### 暴力猜测答案的测试

使用"测试弱锁定"机制中描述的方法确定许多未正确提供的安全答案是否触发锁定机制。

- 在尝试利用安全问题时，首先需要考虑的是需要回答的问题数量。大多数应用程序只需要用户回答一个问题，而某些关键应用程序可能需要用户回答两个甚至更多的问题。
- 下一步是评估安全问题的强度。答案可以通过简单的谷歌搜索或社交工程攻击获得吗？

作为渗透测试人员，以下是利用安全问题方案的分步演练：
- 应用程序是否允许最终用户选择需要回答的问题？如果是，则关注具有：
  - 可能有公开的答案。例如，只需简单的搜索引擎查询即可找到的内容。
  - 事实类答案。例如"第一学校"或其他可以查阅的事实。
  - 很少有可能的答案，如"什么型号是你的第一辆车"。这些问题将为攻击者提供一份可能的答案的简短列表，并且根据统计信息，攻击者可以对答案进行从最可能到最不可能的排名。

- 如果可能，确定需要猜测的数量。
  - 密码重置是否允许无限制尝试？
  - 在给出 x次错误答案之后是否有锁定期？请记住，锁定系统本身可能是一个安全问题，因为攻击者可以利用它对合法用户启动拒绝服务。
  - 根据上述点的分析选择适当的问题，并进行研究以确定最有可能的答案。

成功利用和绕过弱安全问题方案的关键，是找到一个问题或一组问题，它们能够轻松找到答案。如果你完全不确定任何答案，那么就寻找可以给你最大的统计机会猜测正确答案的问题。最后，安全问题的安全性取决于最弱的那个问题。

### References
[The Curse of the Secret Question](https://www.schneier.com/essay-081.html)
[The OWASP Security Questions Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)

## 脆弱密码更改或重置功能测试 Testing for Weak Password Change or Reset Functionalities
ID :WSTG-ATHN-09

### 概述

应用程序的密码更改和重置功能是用户自助更改或重置密码的机制。这种自助服务机制允许用户快速更改或重置其密码，而无需管理员干预。更改密码时，通常会在应用程序中更改密码。重置密码时，它们要么在应用程序中呈现，要么通过电子邮件发送给用户。这可能表示密码以纯文本或可解密格式存储。

### 测试目标
- 确定应用程序在帐户更改过程（更改帐户的密码）的脆弱性；
- 确定密码重置功能的脆弱性，防止猜测或绕过。

### 如何测试
对于密码更改和密码重置，请务必检查：

- 某个用户（非管理员）是否可以更改或重置别人的帐户密码。
- 用户是否可以改变码更改或重置过程，以此更改或重置其他用户或管理员的密码。
- 密码更改或重置过程是否易受CSRF攻击。
#### 测试密码重置
除了前面的检查之外，验证以下内容也很重要：
- 重置密码需要哪些信息？
  - 第一步是检查是否需要机密问题。将密码（或密码重置链接）发送到用户电子邮件地址，而无需首先询问机密问题意味着 100% 依赖该电子邮件地址的安全性，如果应用程序需要高级别的安全性，则不适合这样做。
  - 另一方面，如果使用秘密问题，下一步是评估其强度。本指南的"弱安全测试"问题/答案段落将详细讨论此特定测试。

- 如何将重置密码传达给用户？ 
  - 最不安全的情况是，密码重置工具是否显示密码;如果密码重置工具显示密码，这将使攻击者能够登录到帐户。这时，除非应用程序提供有关上次登录的信息，否则受害者不会知道他们的帐户已被入侵。
  - 不太不安全的情况是，密码重置工具强制用户立即更改其密码。虽然不像第一种情况那样隐秘，但它允许攻击者访问并锁定真正的用户。
  - 如果密码重置是通过电子邮件向用户最初注册的地址或其他一些电子邮件地址完成的，则可实现最佳安全性;这迫使攻击者不仅猜测密码重置发送到哪个电子邮件帐户（除非应用程序显示此信息），而且还要获取该电子邮件帐户以获取临时密码或密码重置链接。

- 重置密码是否随机生成？
  - 此处最不安全的方案是，如果应用程序以明文发送或可视化旧密码，因为这意味着密码不是以哈希形式存储的，这本身就是一个安全问题。
  - 如果密码是使用无法派生的安全算法随机生成的，则可实现最佳安全性。

- 重置密码功能是否要求在更改密码之前进行确认？
  - 为了限制拒绝服务攻击，应用程序应通过电子邮件将链接发送给用户，用户应使用随机令牌，并且仅当用户访问该链接时，重置过程完成。这可确保在确认重置之前，当前密码仍然有效。

#### 测试密码更改
除了上一个测试之外，还必须验证：
- 是否要求旧密码来完成更改？
  - 此处最不安全的方案是，如果应用程序允许在不请求当前密码的情况下更改密码。实际上，如果攻击者能够控制有效的会话，他们可以轻松地更改受害者的密码。另请参阅本指南的"弱密码策略测试"段落。

### 引用
OWASP Forgot Password Cheat Sheet
### 修复
密码更改或重置功能是一个敏感功能，需要某种形式的保护，例如要求用户在过程中重新验证或向用户显示确认屏幕。


## 脆弱的身份验证替代通道测试 Testing for Weaker Authentication in Alternative Channel
ID :WSTG-ATHN-10
### 概述
即使主要的身份验证机制不包含任何漏洞，它仍可能存在漏洞，这些漏洞存在于同一用户帐户的身份验证替代通道中。应进行测试，以确定替代渠道，并在测试范围的情况下识别漏洞。

可以使用替代用户交互通道来绕过主要的身份验证通道，或者发现随后可用于帮助攻击主通道的敏感信息。其中一些通道本身可能是使用不同主机名或路径的单独 Web 应用程序。

例如：
- 标准网站
- 移动或特定设备优化网站
- 辅助功能优化网站
- 替代国家/地区和语言网站
- 使用相同用户帐户的并行网站（例如，提供同一组织不同功能的另一个网站，与用户帐户共享的合作伙伴网站）
- 标准网站的开发、测试、UAT 和暂存版本

现实中，它们也可以是其他类型的应用程序或业务流程：
- 移动设备应用
- 桌面应用程序
- 呼叫中心运营商
- 交互式语音响应或电话树系统

请注意，此测试的重点是替代性通道。某些身份验证的替代方法可能表现为不同的传递内容，并且可能不在甲方要求的测试范围之内。此处不进一步讨论这些问题，应在信息收集和主要身份验证测试期间标识这些。例如：

- 改变功能的渐进式丰富和优雅降级
- 无 Cookie 的网站
- 没有 JavaScript 的站点
- 没有插件（如flash和 Java）的站点


即使测试的范围不允许测试替代通道，也应记录它们的存在。这些可能破坏认证机制的保证程度，并可能成为额外测试的前奏。

#### 例子
主要网站是：http://www.example.com

身份验证功能始终在使用TLS的页面上执行：https://www.example.com/myaccount/

但是，存在一个单独的移动优化网站，该网站根本不使用传输层安全性，并且密码恢复机制较弱：http://m.example.com/myaccount/

### 如何测试
#### 了解主要机制
完全测试网站的主要身份验证功能。这应确定如何颁发、创建或更改帐户，以及如何恢复、重置或更改密码。此外，还应了解任何提升的权限身份验证和身份验证保护措施。这些前体是必要的，以便能够与任何替代通道进行比较。

#### 识别其他渠道
可以使用以下方法找到其他通道：
- 阅读网站内容，尤其是主页，联系我们、帮助页面、支持文章和 FAQs, T&Cs、隐私声明、robots.txt 文件和任何 sitemap.xml 文件。
- 搜索 HTTP 代理日志和以前的信息收集和测试期间收集的字符串，查找在URL或HTML BODY中的：“mobile”, “android”, blackberry", “ipad”, “iphone”, “mobile app”, “e-reader”, “wireless”, “auth”, “sso”, “single sign on”
- 使用搜索引擎查找同一组织的不同网站，或使用具有相同域名、具有类似主页内容或也具有身份验证机制的网站。


对于每个可能的通道，确认用户帐户是否通过这些共享，或提供对相同或类似功能的访问权限。

#### 枚举身份验证功能
对于共享用户帐户或功能的每个替代通道，确定主通道的所有身份验证功能是否可用，以及是否存在其他功能。创建如下网格可能很有用：

|主要|	移动|	呼叫中心|	合作伙伴网站|
|-|-|-|-|
|注册	|是的|	-|	-|
|登录	|是的|	是的|	是（SSO）|
|注销|	-	|-|	-|
|密码重置|	是的|	是的	|-|
|-|	更改密码|	-	|-|

在此示例中，移动具有额外的功能"更改密码"，但不提供"注销"。拨打呼叫中心电话也可以完成数量有限的任务。呼叫中心可能很有趣，因为他们的身份确认检查可能比网站的弱，允许使用此通道帮助攻击用户帐户。

在列举这些内容时，值得注意如何执行会话管理，以防任何通道重叠（例如，限定为同一父域名的 Cookie，允许跨通道的并发会话，但不允许在同一通道上）。

#### 审核和测试
在测试报告中应提及其他渠道，即使这些渠道被标记为"仅信息"和/或"范围外"。在某些情况下，测试范围可能包括备用通道（例如，因为它只是目标主机名上的另一个路径），或者在与所有通道的所有者讨论后可能添加到作用域中。如果允许和授权测试，则应执行本指南中的所有其他身份验证测试，并将测试与主通道进行比较。

### 相关测试用例
应使用所有其他身份验证测试的测试用例。

### 修复
确保在所有通道上应用一致的身份验证策略，以便它们同样安全。