# 文件上传漏洞

文件上传漏洞较之sql注入等漏洞，危害性往往更大。这是因为攻击者常常可以利用此类型漏洞直接上传webshell等恶意文件，直接获取机密数据或系统控制权。

这类漏洞被利用的条件如下：
- 能够上传
- 能够被某个服务器端代码解析、执行
- 能够被攻击者或用户所调用，产生非法的输出。

除了上传服务器端脚本外，还有可能上传的恶意文件有：
- Flash的策略文件 crossdomain.xml
- 病毒、木马
- 含木马的图片



## 漏洞利用
文件上传漏洞通常会与其它漏洞结合使用：
- web server 解析漏洞
- 文件包含漏洞
- 文本编辑器的上传漏洞





## 示例 

### 最简单的情况

程序未作任何验证的文件上传。


代码示例：
```php
<?php
  if (isset($_POST['Upload'])){
    $target_path = DVWA_WEB_PAGE_TO_ROOT."hackable/uploads/";
    $target_path = $target_path . basename($_FILES['uploaded']['name']);

    if(!move_uploaded_file($_FILES['uploaded']['tmp_name'],$target_path)){
      echo '<pre>';
      echo 'Your image was not uploaded.';
      echo '</pre>';
    }else{
      echo '<pre>';
      echo $target_path . ' successfully uploaded.';
      echo '</pre>';
    }

  }
?>
```

### 普通验证
一些网站使用了较为普通的验证content-type方法，例如限制 content-type header 内容。


进行一般验证的文件上传代码示例：
```php
<?php
  if (isset($_POST['Upload'])){
    $target_path = DVWA_WEB_PAGE_TO_ROOT."hackable/uploads/";
    $target_path = $target_path . basename($_FILES['uploaded']['name']);
    $uploaded_name = $_FILES['uploaded']['name']
    $uploaded_type = $_FILES['uploaded']['type']
    $uploaded_size = $_FILES['uploaded']['size']

    if(($uploaded_type == "image/jpeg")) && ($uploaded_size < 100000){

      if(!move_uploaded_file($_FILES['uploaded']['tmp_name'],$target_path)){
        echo '<pre>';
        echo 'Your image was not uploaded.';
        echo '</pre>';
      }else{
        echo '<pre>';
        echo $target_path . ' successfully uploaded.';
        echo '</pre>';
      }    
    }
  }
?>
```

这种情况，使用代理拦截http包后，将前端识别出的 content-type 修改为服务器端可接受的类型就可以绕过上述代码中的验证。因为这个网站并没有验证真实文件的内容类型。

### 文件扩展名验证
越来也多的网站开始设置文件扩展名与content-type结合型的验证。

代码示例：
```php
<?php
  if (isset($_POST['Upload'])){
    $target_path = DVWA_WEB_PAGE_TO_ROOT."hackable/uploads/";
    $target_path = $target_path . basename($_FILES['uploaded']['name']);
    $uploaded_name = $_FILES['uploaded']['name']
    $uploaded_type = $_FILES['uploaded']['type']
    $uploaded_size = $_FILES['uploaded']['size']
    $uploaded_ext = substr($uploaded_name,strrpos($uploaded_name,'.')+1);
    $flag1 = False;
    $flag2 = False;

    if(($uploaded_type == "image/jpeg")) && ($uploaded_size < 100000){
      $flag1 = True;
    }

    if (($uploaded_ext == "jpg" ||$uploaded_ext == "JPG" ||$uploaded_ext == "jpeg" ||$uploaded_ext == "JPEG" )){
      $flag2 = True;
    }
    if $flag1 && $flag2 {

      if(!move_uploaded_file($_FILES['uploaded']['tmp_name'],$target_path)){
        echo '<pre>';
        echo 'Your image was not uploaded.';
        echo '</pre>';
      }else{
        echo '<pre>';
        echo $target_path . ' successfully uploaded.';
        echo '</pre>';
      }    
    }
  }
?>
```

通过抓包、修改文件扩展名可以进行上传webshell文件。但无法直接执行。

可以考虑上传图片马。



使用`grep -R 'eval($_)' /目录`可以进行简单的检测。



## 文件上传检测防护的绕过

### 防护机制

- 客户端：
  - 采取js脚本过滤文件合法性；
- 服务器端：
  - 检查MIME类型，即content-type. 原理是读取文件的前256个字节，判断类型
  - 白名单、黑名单结合的扩展名过滤
  - 将文件置入安全沙箱进行检查
  - 随机数命名文件，防止文件重复和名字猜测。
  - 检查文件头标志位
    - 例如jpeg文件头`0xffd8 0xffe0 0x0010 0x4a46 0x4946`
  - 文件上传目录设置为不可执行
  - 单独设置文件服务器的域名

### 绕过

- 客户端的大多数黑白名单过滤机制，都可以用burpsuite等中间人进行修改、绕过。

- 服务器端绕过主要通过试验确定其检查机制，同时尝试服务器解析漏洞。

#### 黑名单绕过
若使用黑名单限制可解析的文件类型，例如禁止上传：asp，aspx, jsp,php5,php,asa，那么可以尝试：
- 上传.cer 文件（注意cer可被服务器解析，但常被黑名单所遗忘）
- 大小写变形。windows server 不区分大小写，注意 ASP 与 asp 相同，但检测机制中可能疏忽转换。
- windows系统会自动去除尾部的 `.`和空格，但服务器端web代码可能会认为`asp.`或`php.`不在限制之中。

#### 白名单绕过
若使用白名单限制，则重点考虑是否有web server 解析漏洞。

#### 目录验证
如果有迹象显示，web服务器端代码对上传的`路径+文件`进行了目录创建，那么有可能存在目录未验证漏洞。

例如有```<input type="hidden" name="Extension" value="up">```，经试验，发现 up 为可改变的一个目录名。攻击者通过burpsuite等将其改为`12.asp`,然后上传图片木马文件1.jpg。服务器端出现了`12.asp\1.jpg`，这时若服务器为IIS 6.0，则会发生解析漏洞。

#### 截断攻击

很多语言会将 0x00 作为字符串结束，例如c，php等。如果一个文件名为1.phpxxxx，通过中间代理将xx改为0x00，那么上传后就可能绕过检查且被解析。

截断上传攻击在ASP程序中很常见。

例如：有test.asp
```asp
<%
username = request("username")
Response.write username
%>
```

浏览器上输入`http://serverip/test.asp?username=xxx%00admin`,

则只会显示：`xxx`，不会显示0 之后的字符串。

类似这种情况的asp上传页面，我们构造一个webshell文件，名为`123.asp空格sss`，然后利用上传函数上传，再使用burpsuite等拦截修改空格的20为00，那么123.asp就会被解析执行。

#### 构造合法的文件头
检查MIME类型，即content-type. 原理是读取文件的前256个字节。

绕过思路可以是构造一个合法文件头，然后把php放置在其后。

```
...jpeg 合法文件头(256 bytes)....
0x3c3f 0x7068 0x7020 0x7068 ... # <?php eval($_Request("cmd"))?>
```
当然，这还需要由php server解析才能执行。

## 文本编辑器的上传漏洞

常见的文本编辑器有：
- CKEditor（FCKeditor）
- Ewebeditor
- UEditor
- KindEditor
- XHeditor

这些页面编辑器大多有图片上传、视频上传、远程下载等功能。

### FCKeditor 相关漏洞
小于2.4.3的版本大多存在下列漏洞：

#### 敏感信息暴漏
FCKeditor目录存在一些敏感文件，如果这些文件不删除，那么攻击者可以得到一些敏感信息

例如：
- 查看版本信息：`/FCKeditor/editor/dialog/fck_about.html`

#### 黑名单策略错误

- 未过滤 cer，asa等
- 事实上，.php2, .php4, inc, pwml等后缀文件都未被过滤，可以被解析执行。

#### 任意文件上传漏洞 

## 靶场
upload-lab，共19个练习，类似sqli-lab。

相关writeup也可以在github上找到。


## WAF 拦截方式

### 常见检查方式
- 读取整个文件名，对比黑名单内的文件名的后缀，进行过滤
- 看目录权限，如果没有目录权限不允许上传
- 读取文件内容，检查是否为webshell
- 检查请求url中是否异常
- 检查上传文件内容

### WAF运行过程
- 读取request header，并分析
- 读取文件名
- 分析文件内容

### 识别waf
工具：
- wafw00f
- 手工测试，看误报反馈网站，进而了解厂商及版本。

### 绕过常见思路

- fuzz（可以使用fuzzdb）文件名后缀方法，用bp进行测试，寻找黑名单之外的可用文件名；
- 在文件名后追加后最例如`aaa.php.....`
- 路径绕过，某些waf只监控了个别目录，更改上传路径后可能成功；
- 大小写组合混淆（linux下适用）
- 尝试双引号、单引号混合，例如单双结合
- 篡改 post表单中`filename`，使其换行后提交
- 构造多个filname，尝试解析漏洞
- 添加各种空格组合
- 添加分号
- 删除获修改 `Content-Type`，例如大小写改变，内容扩充
- header中添加任意字符
- 双后缀名绕过，例如 `<scr<script>ipt>`
- 删除`form-data`
- 超长文件名获其它载荷绕过
- `Content-Disposition`
- 适用`:` `$`等特殊字符追加在文件名后尝试。
- 编辑器漏洞
- 后缀名为单独参数，例如在`content-disposition:form-data:sufix`,可以尝试修改。
- 自动更名可以尝试%00阶段，或特殊符号尝试绕过。


## Reference
- fuzzdb
- githhub.com/landgrey/upload-lab
- 车王博客 http://payloads.online/archivers/2018-02-05/1

- nikto 扫描敏感文件

