# 加密存储手册

内容取自：OWASP Cryptographic Storage Cheat Sheet

本文给出了一个简单的模型，来保护静态数据。

用户口令，不应使用可逆向算法加密后存储，要使用安全的口令哈希算法。关于口令，口令存储速查表 有更多的内容。

## 架构设计

设计任何应用的第一步，应当是考虑系统架构的全局，这将对后续技术实现有重大影响。

这个过程应该考虑进行应用的威胁建模。

使用专用密钥或密钥管理系统，能够提供更多安全保护，也使密钥管理更加安全。然而这意味着更多的复杂性和管理员负担，所以不一定适合所有应用。注意，许多云环境提供了这项服务，所以可以使用的话应当使用。

### 在哪儿执行加密？
加密可以在应用的许多层面（stack）被执行，例如：
- 在应用层
- 在数据库层
- 在文件系统层（Bitlocker 或 LUKS）
- 在硬件层（加密的RAID 卡或SSDs）

具体使用哪一层，取决于威胁模型。例如硬件层加密在保护物理窃取上是有效的，但不能保护服务器远程访问安全。

### 最小化的保存敏感信息

关于敏感信息，最好的保护方式是不存储它。

注意：对于用户的银行卡号等信息，国家相关法律可能有专门的要求。

## 算法

对称加密算法AES的密钥，至少要128位，理想的是256位，而且应当使用加密模式（下面会讨论）来使用加密算法。

非对称加密，使用带安全曲线（secure cureve）的椭圆曲线算法（ECC），例如Curve25519 比较推荐。如果 ECC不适用，而必须使用 RSA，那么要确保密钥至少为 2048位。

还有很多其它的对称或非对称密码算法，各有优缺点。考虑选用时，应注意以下细节：
- 密钥长度
- 已知攻击和算法脆弱性
- 算法成熟度
- 是否被第三方所接受，例如 NIST's 算法验证程序
- 性能（包括加密和解密）
- 实现库的质量
- 算法的兼容性

有些法规和行业要求，强制了算法的选择。

### 自定义算法

不要使用。

### 加密模式

块加密（如AES）加密任意大小的数据时，有许多种可选的加密模式。同样地，流式加密也有不少选项。这些模式有不同的安全性和性能特点。

如果可能，**尽可能使用认证模式。它保证了完整性、数据的真实性和机密性。最常用的认证模式是GCM和CCM，它们应当作为首选**。

如果，GCM 或 CCM 不能使用，那么应当使用 CTR 模式或 CBC 模式。它们不能提供数据真实性认证，所以真实性认证应当使用其它方式实现。例如使用 Encrypt-then-MAC（EtM） 的技术。注意，使用可变长度消息时，使用这种加密模式要小心。

如果是对加密数据进行随机访问，那么可以选择 XTS 模式。典型用于磁盘加密，所以在Web应用中比较少见。

除非极为特殊的情况下，ECB 模式不建议使用。


### 加固随机数生成

很多关键的安全功能都要求使用随机数或字符串，例如生成加密密钥、IVs（初始化向量）、会话IDs，CSRF token 或口令重置tokens。所以随机数生成需要安全强化，防止攻击者猜测或预测。

没有特殊的硬件，计算机不能生成一个真正的随机数，所以许多系统和语言提供了两类随机数功能。

伪随机数生成器Pseudo-Random Number Generators (PRNG) ，提供低质量的随机数，它生成速度块，能用于非安全相关的功能，例如一个页面的排序结果，随机化UI元素。然而它们一定不能用在任何安全相关的关键功能中。它们很可能被攻击者所猜测预测。

密码学安全伪随机数生成器Cryptographically Secure Pseudo-Random Number Generators (CSPRNG)，是用于生成更高质量的随机数（更为严格的，熵的值很大），可用于安全敏感的功能。但是它们生成的速度较慢，且CPU密集，可能在有大量随机数产生时，会造成阻塞。如果是非安全相关的功能，不建议使用CSPRNG。

下表显示了每种语言推荐的 CSPRNG 算法，以及不能使用于安全相关功能的函数。


|Language| 	Unsafe Functions| 	Cryptographically Secure Functions|
|-|-|-|
|C 	|random(),|rand() |	getrandom(2)|
|Java |	java.util.Random() 	|java.security.SecureRandom|
| PHP |	rand(), mt_rand(), array_rand(), uniqid() |	random_bytes(), random_int() in PHP 7 or openssl_random_pseudo_bytes() in PHP 5|
| .NET/C#| 	Random() 	|RNGCryptoServiceProvider|
| Objective-C |	arc4random() (Uses RC4 Cipher) 	|SecRandomCopyBytes|
| Python |	random() 	|secrets()|
| Ruby |	Random 	|SecureRandom|
| Go |	rand using math/rand package 	|crypto.rand package|
| Rust |	rand::prng::XorShiftRng |	rand::prng::chacha::ChaChaRng and the rest of the Rust library CSPRNGs.|


#### UUIDs 和 GUIDs

统一唯一标识（UUID或GUID）有时可用于快速生成随机字符串。尽管它们能提供一定的随机性，但它们依赖于UUID生成器的版本和类型。

版本1 UUIDs 由高精度时间戳和系统的MAC地址生成，所以不具有随机性。尽管它很难猜。

类型 4 UUIDs 是随机生成的，但是否使用了CSPRNG取决于各自的实现。

除非已经知道这些方法的具体实现机制，否则UUIDs的随机性是不能保证的。

#### 纵深防御

应用在设计时应当考虑即便密码学控制机制失效，系统仍然是安全的。任何以加密形式存储的信息，应该使用别的安全层次进行保护。应用在设计时还应当考虑，不依赖加密URL参数的安全性，应该加强强访问控制，来防止未授权的访问。

## 密钥管理

### 过程

应当执行形式化过程来覆盖所有的密钥管理方面，包括：
- 生成和存储新密钥；
- 分发密钥到请求的部分
- 部署密钥到应用服务器
- 替换（rotating）和销毁就得密钥

### 密钥生成

密钥应当使用密码学安全函数随机生成，例如上面讨论过的CSPRNG。密钥不应当基于一般单词或短语，或者随便敲击键盘形成的随机字串。

如果使用了多个密钥，例如有对数据加密的密钥和对密钥加密的密钥，他们应当彼此完全独立。

### 密钥生命周期和轮换

加密密钥应当在下列条件发生时进行改变替换：
- 当前密钥已经或怀疑被泄露，例如知情员工离职；
- 既定的密码周期（常见为一天、一周、一月、一季、一年，可参考NIST SP 800-57）到期；
- 密钥已经加密了既定额度数量的数据。典型的数量值为 $2^{35}$字节
- 对安全有影响的有重大变化，例如某种成功的密码算法攻击被公布。

一旦上面条件之一满足，就需要生成一个新的密钥，并且立即用来加密所有的新数据。

有两种主要的方法用来处理那些用老密钥加密的数据：
- 解密老数据，然后用新密钥重新加密；
- 使用密钥ID，标记每一项用老密钥加密的数据，存储多个密钥以支持老数据的解密。

上面第一个选项是最常用的方法，对于应用编码和密钥管理都相对简单。但是老的密钥停止使用后，必须被保存一段时间，以防止某些被遗忘的未被解密数据。

重要的是，用于更换密钥的相关代码和过程必须在使用之前就设计好，以便这些密钥在发生入侵时可以被快速的替换。此外，过程的设计也应当允许加密算法或库可以被替换，防止在这些算法或实现暴露新的漏洞。

### 密钥保存

安全的存放密码学密钥是有待解决的最难处理的问题之一。为了解密数据，应用总是需要不断访问密钥，你不能完全在加密后将其完全隐藏。当我们无法完全保护密钥不被攻击者获取时，需要采取一些步骤使之难以被获取。

如果可能，操作系统、框架、云服务提供的安全存储机制应当被使用，包括以下部分：
- 物理硬件安全模块(HSM)
- 虚拟化HSM
- 密钥保险箱，例如亚马逊 KMS 或 Azure Key Vault。
- .Net框架中，由 ProtectedData 类的安全存储APIs

与简单的讲密钥放在配置文件中相比，使用上述类型的安全存储有许多优势。当然这些优势取决于所用的解决方案，但是他们包括：
- 中心化的密钥管理，特别是在容器化的环境中；
- 简化密钥更替和替换；
- 安全密钥生成；
- 简化实现以满足安全合规
- 使攻击者更难于导出或窃取密钥。

在某些情况下，这些都不可用，例如在共享的主机环境中，意味着不可能对任何加密密钥都给出一个高度的保护。然而，接下来一些基本的规则应当被遵循：
- 不要在应用源代码中加入任何硬编码密钥；
- 不要在版本控制系统中加入任何密钥信息；
- 使用严格的许可权限，保护包含密钥的配置文件
- 避免在环境变量中存储密钥，因为他们可能意外暴露，例如使用phpinfo()或通过```/proc/self/environ```文件。

### 分离密钥和数据

如果可能，加密密钥应当被存放在与加密的数据不同的位置。例如，如果数据存放在数据库里，那么密钥应当存放在文件系统里。这意味着，如果攻击者仅有其中之一的访问权，那么他仍无法解密数据。

取决于环境架构，可能存放密钥和数据在不同的系统中，这样提供了更好的隔离程度。

### 加密存储的密钥

如果可能，加密密钥应当单独地以一种加密形式被存储。至少两个不同的密钥当有以下要求：
- 数据加密密钥(DEK)用于加密数据；
- 密钥管理密钥(KEK)用于加密DEK。

为使之有效，DEK和KEK必须分别单独存储。加密的DEK可以和数据一起存放，但这仅在攻击者没有获得KEK的前提下有效。

KEK应当至少与DEK一样强壮。Google的[“信封加密指引”](https://cloud.google.com/kms/docs/envelope-encryption)包含了更多的细节。

简单的应用架构里，例如共享主机环境，KEK和DEK不能分别单独存放，所以上面方法的价值有局限性。作为攻击者可能同时获得两个密钥，然而，它仍然能为攻击者设置障碍。

密钥推导函数（KDF）可以用于生成一个用户提供输入（例如一个口令）的KEK，然后用于加密一个随机生成的DEK。这将使KEK更容易改变（用户改变口令后就改变），此时DEK无变化时，就不需要重新加密数据。

