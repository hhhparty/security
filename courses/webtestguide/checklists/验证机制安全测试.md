# 验证机制安全测试 CHEATSHEET

## 验证类型

网络应用程序可能使用的验证机制有：
- 基于 HTML 表单；
- 基于多因素验证；
- 基于HTTP 协议的BASIC或Digest;
- 基于物理设备（SSL或智能卡）或人体特征的；
- 使用NTLM或kerberos的windows验证；
- 验证服务

## 常见验证功能的设计缺陷

### 弱口令

测试方法：
- 检查与密码强度相关的各种配置和规则；
  - 从web页面、自注册、配置文件等内容中查找；
  - 尝试以多个弱密码注册，了解密码强度规则；
  - 尝试修改原有密码为弱密码。

### 允许暴力破解

不设置任何锁定机制，会遭受暴力破解攻击。

测试方法：
- 使用已有账户，多次尝试错误口令登录，检查是否有锁定机制；
- 尝试使用多个账户，轮流进行错误口令登录，检查是否能够通过不同用户或重设cookie等绕过锁定机制；
- 比较超时前后，错误口令登录与正确口令登录的区别，获取破解口令的可能；
- 在没有账户的情况下，尝试枚举账户，并提交错误口令登录，观察服务器响应；
- 构造常用用户名和密码列表（wordlist），使用工具进行自动化提交和分析。
- 暴力破解时，最好先广度后深度遍历，这样有利于防止触发锁定功能。例如，每次使用不同用户同一口令。

### 反馈中含有详细信息

反馈中的详细信息可以用于确定或猜测可用的用户名或口令，甚至软件漏洞。

burpsuite中的comparer工具可用于比较各响应的差异。

测试步骤：
- 若已有一个可用账户，那么使用该账户和错误口令登录一次，再使用完全随机用户名和任意口令登录一次，比较两者差异，若有差异可用于确定用户名的可用性；
- 记录上面两次错误登录的服务器响应细节，例如状态码，任何重定向，屏幕显示，隐藏信息等
- 如果不能发现问题，可在程序中可以提交用户名和口令的所有地方重复上面尝试。
  - 例如：注册、密码修改、忘记密码等；
- 如果发现了可用账号和不可用账号错误登录的区别，那么可以构建一个自动化测试的方案，注意规避账号错误登录锁定机制。
  - 记录锁定触发条件，进行规避
  - 如果需要用户名和口令一起作为载荷，那么可以使用burpsuite battering ram攻击模式。或者在设计等长度的用户名与密码列表后，使用Pitchfork或Cluster bomb（这两种方式需要同时给出2个payload）。

### 证书传输过程的脆弱

使用不安全的TLS或明文传输，会泄露证书或会话token。

使用TLS（HTTPS）传输，但存在以下不安全实现：
- 使用url传递证书或敏感信息；而不是在post请求主题中传递。
  - 这会在服务器访问日志、referer日志、监控日志等日志中留存。
  - 使用POST传递证书，但又将请求重定向到另一个url来处理请求，并以查询字符串参数提交证书；
- 将证书保存在cookie中，以实现“记住我”、“密码修改”等，若客户端存在漏洞（如xss，浏览器漏洞），证书会泄露。
- 初始访问使用http，登录后使用https是不安全的
  - 攻击者可以伪造初始访问页面，且用户不能通过证书验证其合法性；
  - 被钓鱼的用户，可能将自己证书提交给钓鱼网站。

测试步骤：
- 进行一次成功登录，记录和分析过程中的所有流量；
- 确定在传输过程中的每一种情况，设立拦截规则，标记包含特殊字符的信息；
- 检查是否存在使用url或cookie方式传递证书的情况；
- 检查服务器向客户端传输证书的情况；
- 了解传输的一切细节，并弄清开发者的目的；
- 了解干扰应用程序逻辑，获取其它用户证书的手段；
- 查看是否有非加密传输情况；
- 留意证书中是否含有敏感数据，或被编码加密的敏感数据；
- 留意使用https提交证书，使用http传递登录表单的情况，这可能受到中间人攻击。


### 密码修改功能的脆弱

- 可能提供信息，使攻击者了解用户名是否可用（已有用户）；
- 未实现锁定机制，可能允许用户无限猜测当前口令；
- 仅验证“新密码”是否两次相同，不要求输入旧密码；

测试步骤：
- 找出所有密码修改功能，包括公开的或未明确的某些链接或api
- 使用无效的用户名、无效的现有密码及不匹配的新密码、确认新密码等反复测试，检查各种请求和响应
- 设定枚举和暴力测试，检查结果。

### 忘记密码功能的脆弱

- 可能存在泄露信息，使攻击者可猜测用户名是否可用；
- 质询强度较低，容易猜测或暴力破解
- 未实现锁定机制
- 一些暗示提醒会泄露用户名或口令；
- 在用户正确回答质询后，立即允许用户控制其账号。
  - 正确做法是，准备一个含有强随机有时限的token的url，发送到原用户指定邮箱（注册阶段），或向注册时的手机发送短信，实现对原注册用户的提醒和二次防护；然后进入密码重设阶段。

测试步骤:
- 确定应用程序中所有的忘记密码功能，包括公开的和隐藏的链接；
- 使用受控用户操作一次完整的忘记密码功能，了解工作机制；
- 若使用了质询机制，确定用户是否能够设定或选择自己的质询，设计一组枚举，进行猜测和分析；
- 分析可能有的各种暗示或提醒，猜测用户名和质询答案；
- 设计可用的枚举方案，进行暴力破解
- 确定正确回答质询后是否直接获取控制权

### 记住我功能的脆弱

记住我功能的问题常见于：
- 以cookie中设置明文键值实现此功能，例如“rememberme=someuserid"，而这个cookie提交后，服务器就会视该用户为已登录用户，建立session，可以绕过认证；
- 与上例类似，使用静态token，例如“rememberme=ADFJKSE2324S",此cookie值是一个静态token，一旦获取就可作为合法用户，攻击者还可能通过猜测和测试，枚举大量类似的合法token；
- 在cookie中设置加密或混淆过的token，实现记住我功能。但如果页面存在xss，那么可能会被窃取。

测试步骤：
- 测试所有“记住我”功能，确定这些功能是仅记住用户名还是连同密码一起记住？
  - 如果仅记住用户名，且在后续访问受限资源时仍然要求输入密码，那才是安全的。
- 查找所有客户端缓存数据，例如cookie（永久token），ie的userdata，flash的本地存储对象，silverlight的隔离存储等，判断其中是否包含可识别或可猜测的敏感数据；判断是否可以用于猜测用户名和口令，或伪造请求或伪造身份.
- 即便所有本地存储的token被加密，但攻击者修改加密后内容也可能会造成服务器响应，这一点可参考会话安全；
- 尝试篡改cookie数据，使服务器认为另一用户已经选择在本地使用记住我。

### 用户伪装（托管）功能的缺陷

这种功能在有些场景是有用的，例如：某个操作员使用电话确认用户身份后，改变自身权限为用户，代行某个业务。

这类功能的缺陷常见于：
- 这种功能一般仅为特定操作人员使用，但访问这一功能的url可能未被限制访问。攻击者通过遍历或猜测到此url后，就可访问执行。
- 在执行此功能时，服务器一般会信息且接受客户端提交的数据，以执行某个用户的权限。这有可能被攻击者利用，从而提交任意特权用户数据，代行特权用户权限。
- 该功能的任何逻辑缺陷，都可能导致垂直越权；
- 有些程序在实现用户伪装或托管时，采用了“后门”密码或称为万能密码，这个密码也可以从正常登录界面登录。攻击者可能会通过暴力攻击发现一个用户的两个登录密码。

测试步骤：
- 识别和测试所有具有此功能的web页面；
- 留意所有不通过标准登录页面的用户权限获取方式；
- 尝试伪装为特权或管理员账号；
- 尝试猜测口令，留意“以x登录”的提升。
- 暴露破解口令，留意是否存在多个账号共用一个密码

### 证书确认不完善的缺陷

有些程序在实现时，并没有完全遵守认证最佳实践。

测试方法：
- 以合法用户尝试登录，使用正确口令的一部分或大小写变形，或超长口令登录，观察响应与异常
  - 例如：修改为一个长口令然后在输入时不填写最后一个字符；删去特殊字符等。
  - 根据反馈结果，修改测试例。

### 非唯一性用户

有些应用并不做用户名的唯一性校验，导致同名用户的存在。此时可能会出现两个口令均可登录。或者后注册的用户获得了前面注册用户的身份，能够访问之前用户的各种信息。

测试方法：
- 尝试先后两次用同一用户名注册，检查是否有恰当的校验；
- 如果存在用户名一致性校验，那么这个功能可用于确定已有用户名。
- 如果没有用户名一致性校验，允许同名的多次注册，那么使用同一密码注册两个用户：
  - 如果注册出现错误，那么可以利用这种情况进行密码破解，即若猜对了密码就会报错；
  - 如果注册没有错误，那么尝试是否重新注册已有账号，并使用已有账号权限。

### 可预测的用户名
有些程序的用户名是有规律的，可预测的。攻击者可由此推断大量可用的用户名。

### 可预测的初始密码
与上节相同，在测试时，多注册几个用户，检查用户名和初始密码的规律。

在已知规律下，枚举大量用户名和初始密码，执行自动测试。

## 常见验证机制的执行缺陷

### 异常开放登录

有些验证功能并没有将所有的登录异常正确的结束，而是存在异常处理的漏网之鱼。

测试方法：
- 使用一个可用账号，执行一次完整的登录，获取每次请求和响应的数据。
- 对于每一个认证所需的数据进行异常化处理，重复认证过程，观察响应与异常。
  - 例如：每个cookie，每个表单数据，每个url参数等
  - 测试例：空字符串、完全删除键值对、非常长的值、非常短的值、含有特殊符号的值、在数字处添写字符串（反之亦然）
- 仔细检查各种畸形请求获得的响应，构造更为有效的畸形报文，将他们组合在一起，尽量覆盖各种逻辑分支。

### 多阶段登录机制种的缺陷

多阶段登录虽然从确定用户所知、用户所有、用户生物特征方面提供了安全性，但在实现时仍有可能存在逻辑漏洞。

错误认识：
- 第二阶段或第三阶段是在之前阶段已正确认证的基础上进行的，即不存在绕过之前认证的情况。
- 第二阶段会信任用户提供的数据，因为认为第一阶段已经验证过。攻击者可能在不同阶段扰乱一些标志，触发逻辑漏洞；
- 每个阶段，用户的身份不会发生变化，因此不再每个阶段明确确认用户身份，即不是用所有获取的身份证明去验证身份，而是用其中一部分，这就给只掌握部分证明的攻击者提供了机会。

测试步骤：
- 使用一个可用账号，执行一次完整的登录，获取每次请求和响应的数据。
- 确定各个阶段的响应数据，检查是否有敏感信息，是否某些信息以隐藏字段或cookie形式、url形式返回；
- 使用各种畸形请求，多次重复登录过程，包括
  - 修改隐藏字段、cookie、url参数
  - 不按顺序执行多阶段登录
  - 尝试各种异常行为

- 特别关注由客户端提供，但不由用户输入的内容。这些可能用户保存登录状态，服务器可能会轻信这些数据。

### 不安全的证书（口令）存储

以往很多安全事件说明这一点很常见：
- 以明文形式存储口令
- 以MD5或SHA1存储口令

测试方法：
- 检查所有可能的用户维护功能，是否存在返回用户当前口令的功能？若有说明服务器以明文存储口令，或以不安全方式存储口令。
- 若发现程序存在任意命令执行漏洞，那么利用此漏洞寻找口令位置和值。
- 检查处理口令的hash算法是否位HMAC，是否加盐？



