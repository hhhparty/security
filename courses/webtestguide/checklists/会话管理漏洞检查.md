# 会话管理漏洞检查

会话的作用：
- 标识特定用户身份
- 维持用户操作状态
- 收集用户信息

获得他人的会话，意味着可拥有他人的身份和权限，访问相应的授权信息，实现登录绕过等目的。

会话管理的漏洞常出现在两个位置：
- 会话token的生成
- 会话token的处理

## 会话token的生成
### 确定web应用使用了会话机制
大部分应用都有会话管理，HTTP验证机制和无会话状态管理是两种替代方案。

无会话状态管理的程序，不发布会话令牌，而是传递所有必要数据，一般放在cookie或隐藏字段值中，由客户端管理状态。

此时客户端传送的数据需要加密、签名保护，还必须再数据中包含足够的上下文，防止攻击者收集足够信息后破解内容。
### 确定会话令牌

应用程序可能会综合使用下列部分构成一个会话：
- url组件
- cookie中的某个或某几个字串
- http header中内容
- 隐藏表单内容
- 未发送到客户端的服务器信息

所以确定一个会话令牌需要在使用会话的功能页面进行测试和仔细分析。例如：用户profile页，购物车页等等，多向这种功能页面提交几个不同的请求，观察识别令牌。可以删除一些假设为非令牌的数据，再提交请求，查看功能是否能执行。如果删除了某个数据，应用就不能回到依赖会话才能执行或显示的页面，说明此数据为会话令牌。

### 非随机化令牌

不安全令牌不是随机的，通常与用户的某些信息相关，如登录时间、用户名、邮件地址、手机号码、id、自增自减数字等。

一些程序开发者会使用编码来使其模糊，例如使用XOR,BASE64,ASCII 16进制等。而且有可能对token进行分段后，每个段使用不同的处理方式。

有些令牌很大，很有可能是仅取其中一部分作为令牌，其余只是混淆视听的填充垃圾。

#### 测试与分析方法：
- 首先要了解session token的获取方式，常见有两种：
  - 服务器遇到未提交token的请求，就新建一个会话，分配一个token，例如没有登录就有“记忆”的web服务
  - 用户登录后新建一个会话，分配一个token。


- 当我们获得一个令牌后，可以逐字节的删去或修改，观察其对程序功能的影响。例如用 burp intruder 中的char frobber来修改令牌值，每次修改一个字符，以帮助完成测试。
- 检查令牌是否可预测？例如一个连续的数字段是否有自增、自减特性.可预测会话常见的来自3个方面：
  - 隐含序列
  - 时间依赖
  - 生成数字随机性不强

- 不同时间以相同用户登录，分析服务器发放的令牌之间的区别；
- 不同时间以不同用户登录，分析令牌区别与联系。如果由自我注册功能，可以注册几个名字类似的账户，例如A，AA，AAA等，观察令牌的区别与联系。
- 识别令牌的编码混淆方式，例如：是否只有16进制字符？是否含有字母数字+=/的base64编码等等。
- 找到一个依赖会话tokens的页面，将自己的猜测在这个页面下反复修改令牌，观察变化。
- 若能够自动获取大量令牌（500以上），应尝试令牌随机化检验（FIPS检验）可以使用burpsuite sequencer实现，但要找到获取新令牌的请求才可进行。若检验发现了非随机性字节或字符，可供后续分析token形成算法。
- 通过了解token形成逻辑，编写token计算脚本，尝试利用token绕过登录。

#### 隐含序列
所谓隐含序列是指一个会话token是由一段或几段有隐藏关系的。

- 会话token被混淆后无法预测，可以考虑先解码。

会话token的处理过程可能是：原明文（ascii）->16进制化->base64，还有可能在原明文上先进行计算（例如与某个固定魔术字先加减，然后与序列里的在加减）
- 可以按字节、字、双字进行分段分析（32bit、64bit常见）
- 检查16进制或10进制会话分段，或几个会话之间的区别联系。可以通过差分等办法进行分析。
  - 是否为某个线性函数的结果

#### 时间依赖

这类token常见形式由下面几个部分：
- 一个自增数字段
- 一个时间段，常见的是创世纪以来的毫秒计时（13位）或秒计时（10位）。

如果系统同时不仅为一位用户使用，那么在初始访问或初始登录后等待一段时间，再次访问可能会发现自增字段变化了，时间段也变化了。

如果有计划的查看，会找到其中规律，并猜测其它已登录用户的token。

#### 生成随机数不强
不安全的随机数生成函数，会使以不安全随机数为token的会话不安全。

数据随机性可使用统计学显著性水平检验实现。Burp Sequencer就可以测试web应用程序令牌随机性。

### 加密令牌

有些情况根据用户信息明文加密形成token的做法仍存在漏洞，因为有时不进行解密仍可篡改令牌。

加密token通常使用对称加密算法。
#### ECB加密
ECB将明文划分为同等大小分组（如每组8bytes），然后使用密钥加密每个分组。

此种加密方法有个特定：如果明文分组存在一定模式，那么密文也存在这一模式。因为密文和明文分组对应一致。如果是图片文件，这种方法加密后，就可能直接从密文看出原图轮廓。

分析方法
- 尝试对密文按8字节、16字节、32字节进行分组，看是否可以整分。
- 对其中一部分密文进行修改，然后提交请求，观察结果。
  - 一些程序并不是对整个密文进行验证，而是仅使用其中一部分。
  - 多次测试可能会发现关键字节，而密文的修改也可能正好命中（绕过安全机制）
- 或者可将密文分组中的某一个或几个进行复制替换，反复尝试提交，观察结果。

#### CBC加密
CBC在加密时, 采用了密码块链. 加密过程
- 1.先将所有明文按字节分成多组
- 2.第一分组与初始向量iv异或
- 3.异或后使用加密算法加密，密钥为key，得到分组密文
- 4.分组密文与后续分组明文异或
- 5.重复3-4，直到所有明文处理为密文。



这样处理得到的密文虽然不像ECB，但修改密文仍然可以得到有意义的内容。攻击者把这样的内容传回服务器仍有可能影响安全状态。

例如，攻击者每次对token密文以任意方式修改一个字符，按一定顺序形成大量fuzz，观察服务器响应。可以预料总有一些篡改会被正常解密（服务器可读），这就有可能反馈有价值信息。

使用 burpsuite bit flipper 可以容易测试这个方面漏洞。

假设测试的是第一字节，如果响应或会话状态没有变化，本身也值得注意，这可能意味着第一字节并未真的用于会话管理。

如果响应中可见身份为其它用户身份，那么说明攻击成功。

#### 小结

渗透测试方法：
- 应用采用加密令牌时，具体攻击方法取决于各种因素
  - 分组大小（边界）相对于攻击的数据偏移值
  - 是否允许修改明文结构
  - 是否有密钥或密文的泄露

- 若会话令牌明显无意义或本身不连续的，则考虑令牌已加密
  - 注册多个用户名，每个用户名仅改变或添加一个字符，可以确定应用是否采用分组密码加密。若添加一个字符，导致会话令牌长度增加8或16字节，说明该密码使用了分组密码。当然有的实现进行BASE64编码，可能不是16字节而是20字节。
- 通常是难以利用ECB密码操作漏洞。但可以尝试复制、移动令牌分组，查看是否能已自己的用户或其它用户身份登录应用，或无法登录。
- 尝试 bit flipper 载荷对整个令牌实施burpsuite intruder攻击，测试是否存在 cbc 密码操作漏洞。
- 监视应用的响应，尝试找到其它用户的会话或会话生成机制，尝试扩展权限。
- 反复上述过程，观察异常并分析可能的原因，最终获取可用的他人会话或异常报错信息。

## 会话token处理中的漏洞

当token随机化和加密做的较好时，会话token可能不容易被猜测和伪造，但如果在传递和处理中暴露了，那么攻击者还是可以直接拿来使用，冒名他人合法账户。

- 使用TLS能解决传输中被窃取，但不能解决端点的会话token被窃取。
- 很多网站是http与https混用的，在某些地方的token会以http方式传递，这就为攻击者获取token提供了遍历。
  - 例如：某些邮件系统，登录时使用https，而之后使用http
  - 有些网站用户初始访问就分配了token，但登录转为https后仍不修改这个token，那么攻击者可以等待合法用户登录后劫持这个会话。
  - 有些网站全程使用了https，但在浏览器按“后退”或直接输入url时仍然在cookie中加载可用的token
  - 有时可以篡改http链接为http链接
  - 有些网站访问静态资源使用http，并且访问时带有token
  - 有些网站全部使用https，但如果伪造一个http请求诱使用户点击或自动发出请求的脚本，这个请求会附带token发出。


测试方法:
- 从初始访问点开始，到登录，再到内部受控页面，进行完整的浏览访问，观察每一个新token的获取过程，以及http至https的转换和互用情况（可以使用burp 的浏览历史检查）
- 如果有使用http cookie发送的token，那么检查是否该cookie设置了 Secure 属性
  - 标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端，因此可以预防 man-in-the-middle 攻击者的攻击。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障
- 检查会话token是否存在以http方式传递，有则认为存在中间人攻击可能。
- 初始访问为http，在登录后为https的应用，应当检查是否在登录后赋予新token并始终使用https？
- 在修改url或按浏览器后退时，此token是否会被传递？
- 即便所有链接均为https，那么还要验证该服务器是否仍监听80端口，接收http请求，以及使用待token的http请求是否可能被处理？安全的实现方式是立即对该token所属会话停止服务。

### 日志中泄露token

有些应用，会将token置入日志中。例如：

- 一些监控服务，要求记录用户访问过程的服务，通常会记录这些会话信息；
- 一些web请求使用GET等方法，将token作为url的一部分进行发送（而不是表单或cookie），这也会记录在服务器的日志中。例如：
  - web服务器的日志，如apache access.log
  - 浏览器日志
  - 企业或ISP代理服务器日志
  - 服务器反向代理日志
  - 点击外部站点链接，外部站点会记录referer日志（这种情况非常利于邮件钓鱼，获取邮件系统的会话token）
- 在google等搜索引擎上查询 `inurl:jseesionid` 可以找到很多URL中传送java平台会话token。


渗透测试步骤：
- 确定应用程序的所有功能，找出可查看会话token的任何日志或监控功能。
- 查明谁能访问这些功能，如管理员、验证用户、匿名用户？
- 检查应用是否以url传递token？
  - 开发人员可能以这种方式解决一些特殊问题，但这并不能通过TLS加密变得安全
  - 如果有使用url传递token的情况，那么就要检查所有引用外部链接的地方，如公告牌、站点反馈、问答功能。
  - 如果有外链访问点，在可控情况下，查看referer参数是否会将token带到外部服务器
- 如果能截获大量用户令牌，就可以使用它们访问用户隐私数据。

### 令牌与会话间的映射关系中的漏洞

一个用户在一个时刻仅应当被允许拥有一个会话，换句话说一个用户仅有一个token，这个token仅对应一个会话。

一个用户同一时刻拥有多个token对应多个会话是需要被禁止的。这说明出现了安全问题。

如果一个用户需要执行不同的权限、或在不同地点（浏览器）登录，那么需要结束上一个会话，开启一个新的会话。

有的程序在设计“记住我”功能时，会将静态token以永久cookie方式存放在浏览器端，这种将用户身份完全托管到客户端是不安全的。

渗透测试步骤：
- 用同一个用户账户从不同浏览器或不同主机同时访问web服务，确定是否两个会话都处于活动状态。
  - 如果是，说明应用支持并行会话，这样在截获他人token后就可以利用并不被发现。
- 反复登录、登出，检查是否每次都分配新的token？
  - 如果每次发的token是一样的，那么存在静态token问题。
- 检查会话token的构成（可能需要解码）
  - 如果组成模式可以识别，可以尝试修改与用户相关的部分，使其指向已知授权用户，检查其是否能指向对应的功能。

### 会话终止环节的漏洞

- 正确的结束会话很重要
  - 尽可能缩短会话寿命，降低被截获和重用；
  - 如果用户不再需要现有会话，要明确提供给用户一个结束当前会话的方法（按钮或菜单）

不安全的示例：
- 有些应用在用户授权后，会话会持续好多天有效；
- 有些应用，如果服务器不主动清除会话，则会话将一直有效；
- 有些应用，不提供明确可见的会话退出方法
- 有些应用，表面上清除了会话，但如果客户端再次重用上次token，会话仍然有效
- 最糟糕的是，退出按钮仅仅是关闭了页面，并不与服务器通信（告知服务器“用户退出”）

渗透测试：
- 不要认为通过设置一个新的set-cookie指令就可以清除原有会话；
  - 清除cookie的方法与清楚会话是两码事；
- 检查服务器是否还未清除对应会话。即检查服务器端的清除情况。
  - 登录一个web应用，获得有效token
  - 不使用此token，等待一段时间（如安全需求规定的会话清理时间），使用这个token提交一个访问受保护的页面（如隐私资料页）请求，检查此token的效用
  - 如果页面显示正常，说明会话没有结束，是漏洞
  - 使用反复实验的方法，确定会话超时的具体时间，或验证是否几天内都可使用此会话。
  - 使用Burp intruder 设置递增连续请求之间的时间间隔可自动完成此任务。
- 检查是否有明确可用且满足要求的“退出”功能


### 客户端暴露于令牌劫持风险中

- 存在XSS的客户端页面可能会被利用劫持会话token
- 有的web功能不在身份认证后修改原有token，攻击者可以预先构造一个token，诱使用户使用这个token登录授权。然后服务器会以cookie形式返回这个token，那么攻击者就可以借助其它方法利用此token执行操作。

渗透测试：
- 确定应用是否存在xss漏洞，以及是否可以利用；
- 如果应用向未验证的用户发放token，那么获取一个此类token，然后登陆，检查token是否会更新
  - 如果不更新，那么就可能存在会话固定攻击
- 分析token格式，尝试伪造token，检查服务器是否会认为其有效或为其建立会话；
- 如果web功能完全依靠cookie维持会话（传递token），那么很可能会遭受CSRF攻击。
  - 使用一个浏览器登录应用程序，记住登陆后页面url
  - 尝试用该浏览器（同一进程）访问别的应用，再从别的应用直接访问之前记住的url，查看是否会携带token
  - 如果携带，说明网站的cookie可以被跨站获取，能够被攻击者拥有请求伪造。

### 重新认识cookie

通常服务器端会使用Set-Cookie设置key=value的cookie，然后以响应方式传给客户端；而客户端或浏览器会在下一次请求的头部将服务器发送的key=value放入Cookies中再次传给服务器。

更具体地，Cookie的属性有：
- domain，用于设置cookie的域限制，例如`Set-Cookie:somekey=somevalue; domain=xx.xxx.com;`
  - 服务器不能随意指定域的值，可以是父域或当前域；不能为.com类的顶级域；
  - 默认域范围是当前域和其子域；而有时子域中可能也存在风险。
  - 注意，从安全角度考虑，这个domain应当尽量的小。即不应是父域或子域，仅当前域名本身。
- path，用于设置cookie的可见路径，例如`Set-Cookie:path=/apps/`，表示当前cookie会传递给apps/下的各子路径。
  - 从安全考虑，路径应当尽量具体，特别注意最好不要用web应用根目录。

- http-only
- secure

## 保障会话管理安全

- 生成强大的令牌
- 在会话生命周期中保护令牌

