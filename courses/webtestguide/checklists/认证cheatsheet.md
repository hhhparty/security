# 认证简明手册

## 介绍

Authentication 是验证某个人、实体或网站是谁的过程。认证在web应用的范畴里，通常由提交用户名、ID和一个或多个仅用户个人知晓的私密信息来实现。

会话管理，是一个由服务器维护与之完整交互状态的过程。这要求服务器记住如何在整个事务中对后续请求作出反应。会话在服务器上被一个会话标识所维护，会话标识可以在发送或接受请求时在客户端和服务器端传回或转发。会话应当是每个用户唯一的，难于计算预测的。

## 术语
- Password 在下面统一翻译为："口令"


## 认证通用指引

### 用户IDs

- 确保你的用户名和用户ID是大小不敏感的。例如smith和Smith应当是同一个用户。
- 用户名应当是唯一的。
- 对于高安全级别应用，用户名应当由专门人员指定和保密，而不应当使用用户自定义的公开数据。这样可防止黑客猜测。

#### 邮件地址作为用户ID

有关验证邮件地址的信息，可以参考输入验证cheatsheet email discussion

### 认证解决方案和敏感账户

- 不要允许敏感账户登录。例如那些可能在解决方案内部使用的账户，例如后台、中间件、DB账户，不能通过前端接口登录。
- 对于不可信的访问（例如DMZ区访问），不要使用与内部（中台、后台）认证相同的认证方案。

### 实现正确的口令（Password）强度控制

口令的强度是非常重要的。强口令策略会很难甚至不能被猜测。强口令满足下列特征：
- 口令长度：口令的最小长度应当在应用中被强制。8位以下的口令被认为是弱口令。
- 最大口令长度不应当设的太短。通常最大口令长度是64个字符，这是因为有些hash算法有限制。重要的是设置最大口令长度来防止长口令拒绝服务攻击。

- 不要悄悄的（默认的）截断口令。详情可参考Password Storage Cheat Sheet。
- 允许所有字符均可作为口令字符，包括unicode和空格。不应该有什么限制口令组合的规则。
- 在口令泄露或被入侵后，口令必须被更换。
- 引入密码强度计算，帮助用户创建一个更为复杂的口令，阻止常见的或已被破解的口令。
  - zxcvb 库可用于此目的，但这个库不再被维护。
  - Pwned passwords 是一项已被破解的口令服务。

更多细节信息：
- [ASVS v4.0 Password Security Requirements](https://github.com/OWASP/ASVS/blob/master/4.0/en/0x11-V2-Authentication.md#v21-password-security-requirements)
- [Passwords Evolved: Authentication Guidance for the Modern Era](https://www.troyhunt.com/passwords-evolved-authentication-guidance-for-the-modern-era/)

### 实现安全的口令恢复机制

参考 Forgot Password Cheat Sheet 了解细节。

### 安全存放password

安全存放password参考  Password Storage Cheat Sheet 。

### 使用安全的函数来比较 Password 哈希

用户提供的password与存储在系统中的password，应当通过安全的password 比较函数来比较。

比较函数一般框架和语言都会提供，例如 PHP的 password_verify()。

确保比较函数：
- 有最大输入长度限制，防止DoS；
- 清楚的设置两种变量的类型，免于类型混淆攻击，例如PHP 中的magic hashes ；
- 在固定时间内返回结果，防止计时攻击。

### 仅通过TLS或别的安全传输协议传递Passwords
具体可参考：Transport Layer Protection Cheat Sheet

登录页面和所有后续认证页面必须都经过TLS或其他安全传输层传递。初始登录页作为“login landing page”，必须经过TLS等强传输协议服务。非TLS等强传输层协议会允许攻击者修改登录表单，引起用户凭据（credentials）被发给任意地址。登录后，如果未能对已验证的页面使用TLS或其他强传输，则攻击者可以查看未加密的会话ID并危害用户的已验证会话。

### 对敏感信息要求重新认证

为了缓解CSRF和会话 hijacking攻击，很有必要在更新敏感账户信息前或在敏感事务前，重新要求账户提供凭据（credentials），例如用户的password、email，例如购买物品时进行地址更新。没有这一对策，攻击者能够在不知道当前用户的凭据的情况下，能通过CSRF或XSS攻击执行敏感事务。此外，攻击者可能有临时的物理访问到用户的浏览器或偷窃他们的会话ID ，接管用户会话。

### 考虑强事务认证
一些应用应当使用双因素检查，是否某个用户可以执行敏感的运行。更多信息，参考Trasaction Authorization Cheat Sheet。

#### TLS 客户端认证

TLS客户端认证，也被称为两步TLS认证，由浏览器和服务器共同组成，在TLS握手过程中分别的发送他们TLS证书。如果你可以使用一个已知的CA证书来验证该证书的真实性，那么您可以使用该证书的第三方CA来验证该证书的真实性，服务器必须向用户提供一个专门为其生成的证书，并将值分配给主题，以便可以使用这些值来确定证书应验证的用户。用户在浏览器上安装证书，现在将其用于网站。

当存在下列情况时，这种方法将是很棒的：
- 可以接受用户只能从一台计算机/浏览器访问网站时（甚至是首选）；
- 用户不会轻易被在浏览器上安装TLS证书的过程所吓倒，否则会有人（可能是IT支持人员）为用户完成这项工作。
- 网站需要额外的安全措施。
- 当网站是公司或组织的内部网时，使用它也是一件好主意。

对于那些拥有大量普通用户的公开网站，使用这种方法通常不是一个好主意。例如，在Facebook这样的网站上实现这一点并不是一个好主意。虽然这项技术可以防止用户输入密码（从而防止普通键盘记录器窃取密码），但考虑同时使用密码和TLS客户端身份验证仍然被认为是一个好主意。 

此外，如果客户在一个可以执行SSL/TLS解密的企业代理之后，他将截断证书认证，除非这个网站在代理的白名单中。

更多的，查看[Client-authenticated TLS handshake](https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake)

### 认证和错误消息

在认证函数中使用不正确的实现错误消息，可能被攻击者利用，用于枚举用户ID和password。应用应当以统一的方式进行响应。

#### 认证响应

任何认证机制（login，password reset 或 password recovery），无论是否存在以下情况都必须以统一的错误消息响应，：
- user ID 或 password 不正确
- 账户不存在
- 掌火被锁定或禁用

账户注册功能应该也考虑使用同样的方法给出错误消息。

目标是防止形成差异因子(discrepancy factor)，使攻击者能够执行用户枚举操作。

值得注意的是，业务逻辑本身可能带来与处理时间相关的差异因子。事实上，根据实现的不同，程序处理时间可能会因情况的不同而显著不同（成功与失败），从而使攻击者发起基于时间的攻击。

使用伪代码登录功能的例子：
- 首先使用“quick exit”方法实现

```
IF USER_EXISTS(username) THEN
    password_hash=HASH(password)
    IS_VALID=LOOKUP_CREDENTIALS_IN_STORE(username, password_hash)
    IF NOT IS_VALID THEN
        RETURN Error("Invalid Username or Password!")
    ENDIF
ELSE
   RETURN Error("Invalid Username or Password!")
ENDIF
```

可以清楚的看到，如果用户不存在，应用应当直接抛出error。否则，当用户存在且口令不存在的时候，在应用错误输出之前，明显有更多的处理。反过来，相同错误的响应时间不同，允许攻击者区别错误用户名和错误口令。

- 第二步实现，不依赖“quick exit” 方法：

```
password_hash=HASH(password)
IS_VALID=LOOKUP_CREDENTIALS_IN_STORE(username, password_hash)
IF NOT IS_VALID THEN
   RETURN Error("Invalid Username or Password!")
ENDIF
```

上面的代码对用户或密码，使用了同样的操作步骤，使应用以近似相同的时间返回。

返回一段通用错误消息给用户的问题，是一种用户体验问题。合法用户可能会被一致的消息所混淆，使他难以使用应用并可能在几次尝试后不再使用系统。所以具体如何使用通用错误消息需要基于应用的特性和数据。例如关键应用，由研发和业务团队决定失效场景，用户可以被重定向到支持页面并返回通用的错误消息。

##### 不正确的响应例子

登录功能：

- "Login for User foo: invalid password."
- "Login failed, invalid user ID."
- "Login failed; account disabled."
- "Login failed; this user is not active."

密码恢复：
- "We just sent you a password reset link."
- "This email address doesn't exist in our database."

账户生成（注册）：
- "This user ID is already in use."
- "Welcome! You have signed up successfully."
##### 正确的响应例子
登录：
- "Login failed; Invalid user ID or password."
密码恢复：
- "If that email address is in our database, we will send you an email to reset your password."
账户生成（注册）：
- "A link to activate your account has been emailed to the address provided."

#### 错误代码和URLs

应用应当根据认证尝试响应，返回不同的HTTP错误码。例如正确的请求返回200，错误的返回403。即便返回给用户以通用错误页，HTTP响应代码的不同，也可能泄露信息。

错误的disclosure也可能产生差异因子，参考 error handling cheat sheet 了解更多信息。


### 防护自动化攻击

攻击者可以使用多种不同类型的自动攻击来尝试破坏用户帐户。下面列出了最常见的类型：

|攻击类型| 描述|
|-|-|
|暴力破解（brute force）| 使用用户名或口令词典穷举测试能否成功登录。|
| 凭证填充（Credentials stuffing）| 尝试从另一个站点非法获得的用户名/口令。|
| Password spraying喷射| 使用同一弱口令对众多帐户进行登陆测试|


可以实施不同的保护机制来防御这些攻击。在许多情况下，每一种防御措施都无法提供完整的保护，但是如果以纵深防御方法实施其中的许多防御措施，则可以实现理想的保护水平。

以下各节将主要侧重于防止暴力攻击，尽管这些控制措施也可以有效地抵抗其他类型的攻击。有关防止Credentials stuffing和Password spraying的进一步指导，请参阅 Credential Stuffing Cheat Sheet.

#### 多重身份验证

到目前为止，多因素身份验证（MFA）是抵御大多数与密码有关的攻击（包括蛮力攻击）的最佳防御，Microsoft的分析表明，目前它可以阻止99.9％的帐户泄露。因此，应尽可能实施；但是，取决于应用程序的受众，强制使用MFA可能不切实际或不可行。

Credential Stuffing Cheat Sheet 包含有关实施MFA的更多指南。

#### 帐户锁定

针对这些攻击的最常见保护措施是实施帐户锁定，即在一定次数的失败登录后，系统保持一段时间的锁定，不再允许用户或攻击者进行更多的登录尝试。

登录失败次数的计数器应与帐户本身，而不是源IP地址相关联，以防止攻击者从大量不同的IP地址进行登录尝试。为了实现安全性和可用性之间的平衡，在实施帐户锁定策略时应考虑许多不同的因素：

- 帐户被锁定之前失败的次数（锁定阈值）。
- 这些尝试必须发生的时间段（观察窗口）。
- 帐户被锁定的时间（锁定持续时间）。

某些应用程序不使用固定的锁定持续时间（例如，十分钟），而是使用指数锁定，其中锁定持续时间以很短的时间段（例如，一秒）开始，但是在每次失败的登录尝试后都会翻倍。

在设计帐户锁定系统时，必须注意攻击者通过锁定其他用户的帐户的方式实施拒绝服务攻击。可以采用的一种方法是，总是允许通过一致的“忘记密码”功能重新登录，即便帐户已被锁定。

#### 验证码（CAPTCHA ）

使用有效的验证码可以帮助防止针对帐户的自动登录尝试。但是，许多CAPTCHA实施都有一些弱点，这些弱点使它们可以使用自动化技术解决，也可以外包给可以解决这些问题的服务。因此，CAPTCHA的使用应被视为深度防御控件，以使蛮力攻击更加耗时且昂贵，而不是预防措施。

可能只在少数几次失败的登录尝试后才要求用户解决CAPTCHA提出的问题，而不是要求从第一次登录就要求用户输入验证码，这对用户更友好。

#### 安全提问和可记忆的单词

添加安全问题或令人难忘的单词也可以帮助防止自动攻击，尤其是在要求用户输入从单词中随机选择的多个字符时。应该注意的是，这并不构成多因素身份验证，因为这两个因素是相同的（您知道的事）。此外，安全性问题通常较弱且答案可预测，因此必须谨慎选择。 Choosing and Using Security Questions  包含有关此内容的进一步指导。

## 记录和监控

启用对身份验证功能的日志记录和监视，以实时检测攻击或故障。

- 确保记录所有故障并进行审计
- 确保记录并审计了所有 password 错误
- 确保记录并审计了所有帐户锁定

## 使用不需要密码的身份验证协议

尽管通常认为使用用户和口令组合进行的身份验证，以及使用多因素身份验证是安全的，但在某些情况下，它不是最佳选择，甚至都不安全。

这里的示例是希望从移动设备，另一个网站，桌面或其他情况下连接到Web应用程序的第三方应用程序。发生这种情况时，不允许第三方应用程序存储用户/密码组合是不安全的，因为这样它会将攻击面扩展到他们的手中，而这不在您的控制范围内。对于此以及其他用例，有几种身份验证协议可以保护您避免将用户数据暴露给攻击者。

### OAuth

开放式授权（OAuth）是一种协议，该协议允许应用程序以用户身份针对服务器进行身份验证，而无需密码或充当身份提供者的任何第三方服务器。它使用服务器生成的令牌，并提供授权流的方式，因此客户端（例如移动应用程序）可以告诉服务器哪些用户在使用该服务。

建议使用和实现OAuth 1.0a或OAuth 2.0，因为发现第一个版本（OAuth1.0）容易受到会话固定的影响。

OAuth 2.0依靠HTTPS来确保安全性，目前由Facebook，Google，Twitter和Microsoft等公司的API使用和实现。OAuth1.0a更加难以使用，因为它需要使用用于数字签名的密码库。但是，由于OAuth1.0a不依赖HTTPS来确保安全性，因此它可能更适合高风险的交易。

### OpenId

OpenId是基于HTTP的协议，使用身份提供程序来验证用户是他所说的那个人。这是一个非常简单的协议，它允许服务提供商启动单点登录（SSO）的方式。这允许用户重复使用提供给受信任的OpenId身份提供者的单个身份，并且可以在多个网站中成为同一用户，而无需向任何网站提供密码（除了OpenId身份提供者之外）。

由于其简单性并提供了密码保护，因此OpenId已被广泛采用。OpenId的一些知名身份提供者包括Stack Exchange，Google，Facebook和Yahoo!。

对于非企业环境，只要身份提供者是受信任的，OpenId就被视为安全且通常是更好的选择。

### SAML

安全断言标记语言（SAML）通常被认为与OpenId竞争。最推荐的版本是2.0，因为它的功能非常完善并且提供了强大的安全性。与OpenId一样，SAML使用身份提供程序，但与OpenId不同，它是基于XML的并且提供了更大的灵活性。SAML基于发送XML数据的浏览器重定向。此外，SAML不仅由服务提供商发起；它也可以从身份提供者发起。这使用户可以在仍通过身份验证的同时浏览不同的门户，而无需执行任何操作，从而使过程透明。

尽管OpenId占领了大多数消费市场，但SAML通常是企业应用程序的选择。原因通常是很少有OpenId身份提供程序被认为是企业级的（这意味着它们验证用户身份的方式没有企业身份要求的高标准）。更常见的是看到Intranet网站内部使用了SAML，有时甚至使用Intranet中的服务器作为身份提供者。

在过去的几年中，每当需要Web服务和Web联合企业联合身份验证时，像SAP ERP和SharePoint（使用Active Directory联合身份验证服务2.0的SharePoint）之类的应用程序已决定使用SAML 2.0身份验证作为单点登录实现的首选方法。应用程序。

**另请参见：[SAML安全备忘单]（SAML_Security_Cheat_Sheet.md）**

### FIDO

快速身份在线（FIDO）联盟创建了两个协议来促进在线身份验证：通用身份验证框架（UAF）协议和通用第二因素（U2F）协议。虽然UAF专注于无密码身份验证，但U2F允许在现有的基于密码的身份验证中添加第二个因素。两种协议都基于公钥密码学质询-响应模型。

UAF利用了用于身份验证的设备上现有的安全技术，这些设备包括指纹传感器，摄像机（面部生物特征），麦克风（语音生物特征），可信执行环境（TEE），安全元素（SE）等。该协议旨在将这些设备功能插入通用的身份验证框架。UAF可与本机应用程序和Web应用程序一起使用。

U2F使用硬件令牌（通常是USB）增强了基于密码的身份验证，该令牌存储加密的身份验证密钥并将其用于签名。用户可以将同一令牌用作多个应用程序的第二要素。U2F可与Web应用程序一起使用。它通过使用网站的URL查找存储的身份验证密钥来提供“防止网络钓鱼的保护”。

## 密码管理员

密码管理器是可以自动管理大量不同凭据的程序、浏览器插件或Web服务。大多数密码管理器都具有允许用户通过将密码粘贴到登录表单中或模拟用户键入密码来轻松在网站上使用它们的功能。

Web应用程序至少应遵守以下建议，以免使密码管理器的工作变得不必要地困难：

- 使用标准的HTML表单输入具有适当“类型”属性的用户名和密码。
- 避免使用基于插件的登录页面（例如Flash或Silverlight）。
- 如“密码存储备忘单”中所述，实现合理的最大密码长度，例如64个字符。
- 允许在密码中使用任何可打印的字符。
- 允许用户粘贴到用户名和密码字段中。
- 只需按一下Tab键，即可让用户在用户名和密码字段之间导航。