# PasswordPassword存储安全简明手册

## 介绍

大多数用户会在不同应用中使用重复的Password（password），因此Password一旦泄露，用户的多个账户可能会遭受损失。有必要在存储Password时增加防护，以防止攻击者轻易获取。

与大多数密码学领域一样，这需要考虑许多不同的因素，但是幸运的是，大多数现代语言和框架都提供了内置功能来帮助存储Password，从而处理了很多复杂性。

这里涉及了存储Password的多个方面，总的原则是：
- 除非有特殊理由，否则应默认使用 Bcrypt。
- 为你的系统设置合理的 work factor。
- 使用 salt 处理Password。
- 考虑使用 pepper，提供额外保护。

## 背景

### 哈希与加密

哈希和加密是两个经常被混淆或错误使用的术语。它们之间的主要区别在于散列是一种“单向”函数（即，不可能“解密”散列并获得原始值），而加密是一种双向函数。

在几乎所有情况下，都应该对Password进行哈希处理（保证单向性）而不是加密，因为攻击者很难或不可能从哈希中获取原始密码。

仅在必须能够获取原始Password的极端情况下才使用加密。可能需要这样做的一些示例是：
- 如果应用程序需要使用Password，对不支持SSO的外部旧式系统进行身份验证。
- 如果有必要从密码中检索单个字符。

解密Password的能力存在严重的安全风险，因此应进行充分的风险评估。在可能的情况下，应使用替代体系结构，以避免需要以加密形式存储Password。

该备忘单专注于密码哈希-有关加密密码的更多指导，请参见Cryptographic Storage Cheat Sheet。

### 攻击者如何破解密码哈希

尽管无法“解密”密码散列以获得原始密码，但是在某些情况下可以“破解”散列。基本步骤是：

- 选择一个可能的候选者（例如“密码”）。
- 计算输入的哈希值。
- 将其与目标哈希值进行比较。

然后针对大量潜在的候选密码重复此过程，直到找到匹配项。有很多不同的方法可用于选择候选密码，包括：

- 蛮力（尝试所有可能的候选人）。
- 常用密码的字典或单词表
- 从其他受感染站点获得的密码列表。
- 更复杂的算法，例如 [Markov chains](https://github.com/magnumripper/JohnTheRipper/blob/bleeding-jumbo/doc/MARKOV) 或 [PRINCE](https://github.com/hashcat/princeprocessor)
- 图案或遮罩（例如“ 1个大写字母，6个小写字母，1个数字”）。

不能保证破解过程成功，成功率将取决于许多因素：
- 密码强度。
- 算法的速度（或现代算法的 work factor）。
- 目标密码的数量（假设它们具有唯一的 salt ）。
 
使用现代哈希算法存储的强密码对于攻击者而言实际上应该是不可能破解的。

## 散列概念

### Salting 加Salt

Salt 指唯一的、随机生成的字符串，在哈希过程中会添加到每个Password中。由于 Salt 对于每个用户而言都是唯一的，因此攻击者必须使用相应的 Salt 一次破解一个哈希，而不是能够一次计算哈希并将其与每个存储的哈希进行比较。这使得破解大量哈希变得非常困难，因为所需时间与哈希数量成正比增长。

Salt 化还防止使用彩虹表或基于数据库的查找来预先计算哈希。最后，加Salt意味着无法在不破解哈希的情况下确定两个用户是否具有相同的Password，因为即使密码相同，不同的Salt也会导致不同的哈希。

[现代哈希算法](#modern-algorithms)（例如Argon2或Bcrypt）会自动对密码加Salt，因此在使用它们时不需要其他步骤。但是，如果您使用的是[旧密码哈希算法](#legacy-algorithms)，则需要手动实现加Salt。执行此操作的基本步骤是：
- 使用密码学安全函数（参考加密存储checklist）生成Salt。
  - Salt的长度至少应为16个字符。
  - 将Salt编码为安全字符集，例如十六进制或Base64。
- 将Salt和Password组合在一起。
  - 这可以使用简单的字符串连接，或诸如HMAC的构造函数来完成。
- 对Password和Salt组合结果进行hash运算。
- 存储Salt和Password哈希值。

### Pepper （Pepper 粉）

除了加Salt以外，还可以使用[pepper](https://en.wikipedia.org/wiki/Pepper_%28cryptography%29)来提供额外的保护层。它类似于Salt，但有两个主要区别：

- Pepper在所有存储的密码之间共享，而不是像Salt（每个Password都有唯一的salt）。
- 与Salt不同，**Pepper 不应存储在数据库中**。

Pepper 的目的是防止攻击者仅通过访问数据库（例如，如果他们利用SQL注入漏洞或获得数据库的备份）获取数据，此时没有Pepper无法破解任何哈希。

Pepper 的长度至少应为32个字符，并且应随机生成。应该使用操作系统提供的安全存储API，将其存储在应用程序配置文件中（具有适当的权限保护），或者存储在硬件安全模块（HSM）中。

传统上，Pepper 使用与Salt类似的方式，即执行拼接后进行hash运算 ```hash($ pepper.$ password）```。

另一种方法是先进行普通的Passwordhash计算，然后使用对称的加密密钥对哈希值进行加密，然后将其存储在数据库中。此处用于加密的对称密钥作为 Pepper 。这就避免了传统的加 Pepper 方法中的一些问题，并且如果认为 Pepper 受到损害，则可以使 Pepper 的更换更加容易。

#### 缺点

Pepper 的主要问题是它们的长期维护。更改使用中的 Pepper 将使数据库中存储的所有现有Password无效，这意味着如果花椒被盗，还不能轻易更改它。

一种解决方案是将 Pepper 的ID与关联的Passwordhash值一起存储在数据库中。当需要更新Pepper 时，可以使用新Pepper 来更新此ID的哈希值。尽管应用程序将需要存储当前使用的所有辣椒，但这确实提供了一种替代受损Pepper的方法。

### Work factor

Work factor 实质上是为每个Password执行的哈希算法迭代次数（通常是$2 ^ {work}$次迭代）。Work factor的目的是使计算散列在计算上更加昂贵，从而降低了攻击者尝试破解密码散列的速度。Work factore 通常存储在哈希输出中。

选择Work factor时，需要在安全性和性能之间取得平衡。较高的Work factor将使哈希值更难以被攻击者破解，但也会使验证登录尝试的过程变慢。如果Work factor过高，这可能会降低应用程序的性能，并且攻击者还可以通过进行大量的登录尝试来耗尽服务器的CPU来利用它进行拒绝服务攻击。

理想的Work factor没有一个黄金法则-它取决于服务器的性能和应用程序上的用户数量。确定最佳Work factor将需要在应用程序使用的特定服务器上进行实验。通常，计算哈希值应少于一秒钟，尽管在流量较高的站点上，哈希值应大大少于此值。

#### 升级Work factor

拥有Work factor的一个主要优点是，随着硬件的强大和廉价，它可以随着时间的推移而增加。以摩尔定律（即，给定价格点的计算能力每18个月翻一番）为近似值，这意味着Work factor应每18个月增加1。

升级Work factor的最常见方法是等待用户下次进行身份验证，然后使用新的Work factor重新散列其密码。这意味着不同的哈希将具有不同的Work factor，并且如果用户不重新登录到应用程序，则可能导致哈希永远无法升级。根据应用程序的不同，删除较旧的密码哈希值并要求用户在下次登录时重置密码可能是适当的，以避免存储较旧且安全性较低的哈希值。

在某些情况下，可能不需要原始密码就可以提高哈希的Work factor，尽管常见的哈希算法（例如Bcrypt和PBKDF2）不支持此功能。

### 最大Password长度

一些哈希算法（例如Bcrypt）的输入最大长度，对于大多数实现而言，最大长度为72个字符。（有些报告提出其他实现的最大长度较低，但在撰写本文时尚未确定）。在使用Bcrypt的情况下，应在输入中强制使用64个字符的最大长度，因为它提供了足够高的限制，同时仍允许出现字符串终止问题，并且不会泄露程序使用了Bcrypt。

此外，由于现代哈希函数在计算上的昂贵，如果用户可以提供非常长的密码，则可能存在拒绝服务漏洞，例如[Django](https://www.djangoproject.com/weblog/2013/sep/15/security /)。

为了防止这两个问题，应设置最大密码长度。对于Bcrypt，这应该是64个字符（由于算法和实现方面的限制），而对于其他算法，则应该在64和128个字符之间。

尽管实现最大密码长度确实会减少密码的可能密钥空间，但是64个字符的限制仍然留下了至少$2 ^ {420}$的密钥空间，这对于攻击者来说是完全不可解的。因此，这并不意味着安全性的显着降低。

#### 预哈希passwords

另一种方法是先使用快速算法（例如SHA-256）对用户提供的密码进行预哈希处理，然后再使用更安全的算法（例如Bcrypt）对生成的哈希进行哈希处理。例如，```bcrypt(sha256($ password)) ```。

尽管此方法解决了用户输入任意长度的哈希算法较慢的问题，但它还引入了一些漏洞，这些漏洞可能使攻击者更容易破解哈希。

如果攻击者能够从两个不同的受感染站点获得密码哈希，其中一个使用```bcrypt(sha256($ password)) ```存储密码，另一个使用普通的```sha256($ password)```存储密码，攻击者可以使用第二个站点未破解的SHA-256哈希作为候选密码来尝试从第一个（更安全）的站点破解这些哈希。如果在两个站点之间重复使用密码，这可以有效地使攻击者剥离Bcrypt层，然后将精力集中在破解更容易的SHA-256哈希上。

使用预哈希时，请确保将第一个哈希算法的输出安全地编码为十六进制或base64，因为如果输入包含空字节]，某些哈希算法（例如Bcrypt）可能会以不良方式运行（https：//blog.ircmaxell .com / 2015/03 / security-issue-combining-bcrypt-with.html）。

由于这些问题，通常首选的方法是限制最大密码长度。仅在有特定要求的情况下才应执行密码的预哈希处理，并且已经采取了适当的措施来减轻上述问题。

## Password 哈希算法

### 现代算法

有许多专门设计用于安全存储password的现代哈希算法。这意味着它们应该很慢（不同于像MD5和SHA-1这样设计得很快的算法），并且可以通过更改work factor来配置它们的速度。

应该考虑的主要三种算法如下。

#### Argon2id

Argon2是2015年password 散列比赛的获胜者。该算法有三种不同版本，应使用 Argon2id 变体，因为它提供了一种平衡的方法来抵御旁通道攻击和基于GPU的攻击。

Argon2具有三个可以配置的不同参数，而不是像其他算法那样简单的 Work factor，这意味着针对环境正确调整更为复杂。该规范包含[选择适当参数的指南]（https://password-hashing.net/argon2-specs.pdf），但是，如果您无法适当调整它，则可以使用一种更简单的算法，例如 Bcrypt可能是一个更好的选择。

#### PBKDF2

NIST推荐[PBKDF2]（https://en.wikipedia.org/wiki/PBKDF2）和具有FIPS-140验证的实现。因此，当需要这些算法时，它应该是首选算法。此外，它在.NET框架中是开箱即用的，因此通常在ASP.NET应用程序中使用。

PBKDF2可以基于多种不同的哈希算法与HMAC一起使用。HMAC-SHA-256被NIST广泛支持并推荐。

PBKDF2的工作因数是通过迭代计数实现的，该迭代计数应至少为10,000（尽管在更高安全性的环境中，最高值为100,000可能合适）。

#### Bcrypt

[Bcrypt]（https://en.wikipedia.org/wiki/Bcrypt）是该算法中得到最广泛支持的，并且应该是默认选择，除非对PBKDF2有特定要求，或者需要适当的知识来调试Argon2。

Bcrypt的默认Work factor是10，除非在较旧或较低功率的系统上运行，否则通常应将其提高到12。

### 旧版算法

在某些情况下，通常由于使用传统语言或环境而无法使用[现代哈希算法]（＃modern-algorithms）。在可能的情况下，应使用第三方库来提供这些算法。但是，如果仅有的可用算法是旧算法，例如MD5和SHA-1，则可以采取许多步骤来提高存储密码的安全性。

- 使用现有最强的算法：SHA-512 > SHA-256 > SHA-1 > MD5。
- 使用 pepper。
- 为每个密码使用唯一的 salt, salt应使用密码学安全随机数生成器生成。
- 使用算法的大量迭代（至少10,000次，根据硬件速度的不同，可能会更多）。

应该强调的是，这些步骤**不如使用现代哈希算法**，并且仅在没有其他选项可用的情况下才应采用这种方法。

### 升级旧式哈希

对于使用安全性较低的哈希算法（例如MD5或SHA-1）构建的较旧应用程序，应将这些哈希值升级为更现代和安全的哈希值。当用户接下来输入password（通常通过在应用程序上进行身份验证）时，应使用新算法重新加密它。最好使用户的当前密码到期并要求他们输入一个新密码，这样，他们的密码的任何较旧（较不安全）的哈希对攻击者都不再有用。

但是，这种方法意味着旧的（安全性较低）密码哈希将存储在数据库中，直到用户下次登录为止，并且可能会无限期地存储。有两种主要方法可以解决此问题。

一种方法是使长时间不活动的用户失效并删除其密码哈希，并要求他们重置密码以再次登录。尽管安全，但是这种方法并不是特别用户友好，并且使大量用户的密码过期可能会给支持人员造成麻烦，或者可能被用户解释为违规的标志。但是，如果在登录时实施密码哈希升级代码与删除旧的密码哈希之间存在合理的延迟，则大多数活动用户应该已经更改了密码。

一种替代方法是将现有的密码哈希用作更安全算法的输入。例如，如果应用程序最初将密码存储为“ md5（$ password）”，则可以轻松地将其升级为“ bcrypt（md5（$ password））”。以这种方式对哈希进行分层可以避免需要知道原始密码的需要，但是，如[哈希前密码]（＃pre-hashing-passwords）部分中所讨论的那样，可以使哈希更容易破解。因此，下次用户登录时，应使用用户密码的直接哈希替换这些哈希。

### 自定义算法

编写自定义密码代码（例如哈希算法）是“非常困难”的，并且绝不应在学术活动之外进行。使用未知算法或定制算法可能带来的任何潜在好处将大大地被其中存在的弱点所掩盖。

我们的忠告是：**不要这样做。**