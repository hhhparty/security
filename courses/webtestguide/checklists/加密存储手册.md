# 加密存储手册

内容取自：OWASP Cryptographic Storage Cheat Sheet

本文给出了一个简单的模型，来保护静态数据。

用户口令，不应使用可逆向算法加密后存储，要使用安全的口令哈希算法。关于口令，口令存储速查表 有更多的内容。

## 架构设计

设计任何应用的第一步，应当是考虑系统架构的全局，这将对后续技术实现有重大影响。

这个过程应该考虑进行应用的威胁建模。

使用专用密钥或密钥管理系统，能够提供更多安全保护，也使密钥管理更加安全。然而这意味着更多的复杂性和管理员负担，所以不一定适合所有应用。注意，许多云环境提供了这项服务，所以可以使用的话应当使用。

### 在哪儿执行加密？
加密可以在应用的许多层面（stack）被执行，例如：
- 在应用层
- 在数据库层
- 在文件系统层（Bitlocker 或 LUKS）
- 在硬件层（加密的RAID 卡或SSDs）

具体使用哪一层，取决于威胁模型。例如硬件层加密在保护物理窃取上是有效的，但不能保护服务器远程访问安全。

### 最小化的保存敏感信息

关于敏感信息，最好的保护方式是不存储它。

注意：对于用户的银行卡号等信息，国家相关法律可能有专门的要求。

## 算法

对称加密算法AES的密钥，至少要128位，理想的是256位，而且应当使用加密模式（下面会讨论）来使用加密算法。

非对称加密，使用带安全曲线（secure cureve）的椭圆曲线算法（ECC），例如Curve25519 比较推荐。如果 ECC不适用，而必须使用 RSA，那么要确保密钥至少为 2048位。

还有很多其它的对称或非对称密码算法，各有优缺点。考虑选用时，应注意以下细节：
- 密钥长度
- 已知攻击和算法脆弱性
- 算法成熟度
- 是否被第三方所接受，例如 NIST's 算法验证程序
- 性能（包括加密和解密）
- 实现库的质量
- 算法的兼容性

有些法规和行业要求，强制了算法的选择。

### 自定义算法

不要使用。

### 加密模式

块加密（如AES）加密任意大小的数据时，有许多种可选的加密模式。同样地，流式加密也有不少选项。这些模式有不同的安全性和性能特点。

如果可能，**尽可能使用认证模式。它保证了完整性、数据的真实性和机密性。最常用的认证模式是GCM和CCM，它们应当作为首选**。

如果，GCM 或 CCM 不能使用，那么应当使用 CTR 模式或 CBC 模式。它们不能提供数据真实性认证，所以真实性认证应当使用其它方式实现。例如使用 Encrypt-then-MAC（EtM） 的技术。注意，使用可变长度消息时，使用这种加密模式要小心。

如果是对加密数据进行随机访问，那么可以选择 XTS 模式。典型用于磁盘加密，所以在Web应用中比较少见。

除非极为特殊的情况下，ECB 模式不建议使用。


### 加固随机数生成

很多关键的安全功能都要求使用随机数或字符串，例如生成加密密钥、IVs（初始化向量）、会话IDs，CSRF token 或口令重置tokens。所以随机数生成需要安全强化，防止攻击者猜测或预测。

没有特殊的硬件，计算机不能生成一个真正的随机数，所以许多系统和语言提供了两类随机数功能。

伪随机数生成器Pseudo-Random Number Generators (PRNG) ，提供低质量的随机数，它生成速度块，能用于非安全相关的功能，例如一个页面的排序结果，随机化UI元素。然而它们一定不能用在任何安全相关的关键功能中。它们很可能被攻击者所猜测预测。

密码学安全伪随机数生成器Cryptographically Secure Pseudo-Random Number Generators (CSPRNG)，是用于生成更高质量的随机数（更为严格的，熵的值很大），可用于安全敏感的功能。但是它们生成的速度较慢，且CPU密集，可能在有大量随机数产生时，会造成阻塞。如果是非安全相关的功能，不建议使用CSPRNG。

下表显示了每种语言推荐的 CSPRNG 算法，以及不能使用于安全相关功能的函数。


|Language| 	Unsafe Functions| 	Cryptographically Secure Functions|
|-|-|-|
|C 	|random(),|rand() |	getrandom(2)|
|Java |	java.util.Random() 	|java.security.SecureRandom|
| PHP |	rand(), mt_rand(), array_rand(), uniqid() |	random_bytes(), random_int() in PHP 7 or openssl_random_pseudo_bytes() in PHP 5|
| .NET/C#| 	Random() 	|RNGCryptoServiceProvider|
| Objective-C |	arc4random() (Uses RC4 Cipher) 	|SecRandomCopyBytes|
| Python |	random() 	|secrets()|
| Ruby |	Random 	|SecureRandom|
| Go |	rand using math/rand package 	|crypto.rand package|
| Rust |	rand::prng::XorShiftRng |	rand::prng::chacha::ChaChaRng and the rest of the Rust library CSPRNGs.|


#### UUIDs 和 GUIDs

统一唯一标识（UUID或GUID）有时可用于快速生成随机字符串。尽管它们能提供一定的随机性，但它们依赖于UUID生成器的版本和类型。

版本1 UUIDs 由高精度时间戳和系统的MAC地址生成，所以不具有随机性。尽管它很难猜。

类型 4 UUIDs 是随机生成的，但是否使用了CSPRNG取决于各自的实现。

除非已经知道这些方法的具体实现机制，否则UUIDs的随机性是不能保证的。

#### 纵深防御

应用在设计时应当考虑即便密码学控制机制失效，系统仍然是安全的。任何以加密形式存储的信息，应该使用别的安全层次进行保护。应用在设计时还应当考虑，不依赖加密URL参数的安全性，应该加强强访问控制，来防止未授权的访问。

## 密钥管理

### 过程

应当执行形式化过程来覆盖所有的密钥管理方面，包括：
- 生成和存储新密钥；
- 分发密钥到请求的部分
- 部署密钥到应用服务器
- 替换（rotating）和销毁就得密钥

### 密钥生成

密钥应当使用密码学安全函数随机生成，例如上面讨论过的CSPRNG。密钥不应当基于一般单词或短语，或者随便敲击键盘形成的随机字串。


